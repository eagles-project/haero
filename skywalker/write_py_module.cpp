#include "haero/modal_aerosol_config.hpp"
#include "skywalker.hpp"

namespace {

// Writes the given input variable to our Python module.
void write_input_var(FILE* file,
                     const std::vector<skywalker::InputData>& inputs,
                     const std::string& var_name) {
  fprintf(file, "input.%s = [", var_name.c_str());
  for (const auto& input : inputs) {
    auto var = input[var_name];
    fprintf(file, "%g, ", var);
  }
  fprintf(file, "]\n");
}

// Writes the given output variable to our Python module.
void write_output_var(FILE* file,
                      const std::vector<skywalker::OutputData>& outputs,
                      const std::string& var_name) {
  fprintf(file, "output.%s = [", var_name.c_str());
  for (const auto& output : outputs) {
    auto var = output[var_name];
    if (var == var) {
      fprintf(file, "%g, ", var);
    } else {
      fprintf(file, "nan, ");
    }
  }
  fprintf(file, "]\n");
}

// Writes output metrics to our Python module.
void write_output_metrics(FILE* file,
                          const std::vector<skywalker::OutputData>& outputs) {
  if (!outputs.empty()) {
    for (const auto& metrics_kv : outputs[0].metrics) {
      const std::string& metric = metrics_kv.first;
      fprintf(file, "output.metrics.%s = [", metric.c_str());
      for (const auto& output : outputs) {
        const auto iter = output.metrics.find(metric);
        EKAT_ASSERT(iter != output.metrics.end());
        auto value = iter->second;
        if (value == value) {
          fprintf(file, "%g, ", value);
        } else {
          fprintf(file, "nan, ");
        }
      }
      fprintf(file, "]\n");
    }
  }
}

}  // namespace

namespace skywalker {

void write_py_module(const std::vector<InputData>& inputs,
                     const std::vector<OutputData>& outputs,
                     const std::string& py_module_name) {
  const auto& aero_config = inputs[0].aero_config;

  // Is this a user-defined configuration?
  bool user_config = (aero_config.num_modes() == 0);

  FILE* file = fopen(py_module_name.c_str(), "w");
  fprintf(file, "# This file was automatically generated by skywalker.\n\n");
  fprintf(file, "from math import nan as nan\n\n");
  fprintf(
      file,
      "# Object is just a dynamic container that stores input/output data.\n");
  fprintf(file, "class Object(object):\n");
  fprintf(file, "    pass\n\n");

  // Write input data.
  fprintf(file, "# Input is stored here.\n");
  fprintf(file, "input = Object()\n");
  if (not user_config) {
    fprintf(file, "input.atmosphere = Object()\n");
    fprintf(file, "input.aerosols = Object()\n");
    fprintf(file, "input.aerosols.interstitial = Object()\n");
    fprintf(file, "input.aerosols.cloudy = Object()\n");
    for (int m = 0; m < aero_config.num_modes(); ++m) {
      auto mode = aero_config.aerosol_modes[m];
      fprintf(file, "input.aerosols.interstitial.%s = Object()\n",
              mode.name().c_str());
      fprintf(file, "input.aerosols.cloudy.%s = Object()\n",
              mode.name().c_str());
    }
    fprintf(file, "input.gases = Object()\n");
  }  // if not user config
  fprintf(file, "input.user = Object()\n");

  if (not user_config) {
    // Atmosphere state data.
    write_input_var(file, inputs, "atmosphere.temperature");
    write_input_var(file, inputs, "atmosphere.pressure");
    write_input_var(file, inputs, "atmosphere.relative_humidity");
    write_input_var(file, inputs, "atmosphere.height");
    write_input_var(file, inputs, "atmosphere.hydrostatic_dp");
    write_input_var(file, inputs, "atmosphere.planetary_boundary_layer_height");

    // Now we write out aerosol prognostics.
    for (int m = 0; m < aero_config.num_modes(); ++m) {
      auto mode = aero_config.aerosol_modes[m];
      for (int cloudy = 0; cloudy < 2; ++cloudy) {
        std::string prefix;
        if (cloudy) {
          prefix = "aerosols.cloudy.";
        } else {
          prefix = "aerosols.interstitial.";
        }
        auto num_mix_ratio_name =
            prefix + mode.name() + std::string(".number_mix_ratio");
        write_input_var(file, inputs, num_mix_ratio_name.c_str());
        auto species_for_mode = aero_config.aerosol_species_for_mode(m);
        for (auto species : species_for_mode) {
          auto sym = species.symbol();
          transform(sym.begin(), sym.end(), sym.begin(), ::tolower);
          auto species_name = prefix + mode.name() + std::string(".") + sym;
          write_input_var(file, inputs, species_name.c_str());
        }
      }
    }

    // Write out gases.
    for (int g = 0; g < aero_config.num_gases(); ++g) {
      auto gas = aero_config.gas_species[g];
      auto gas_name = std::string("gases.") + gas.symbol();
      std::transform(gas_name.begin(), gas_name.end(), gas_name.begin(),
                     ::tolower);
      write_input_var(file, inputs, gas_name.c_str());
    }
  }  // if not user config

  // Write out user-defined parameters.
  for (const auto& user_param : inputs[0].user_params) {
    const auto& name = std::string("user.") + user_param.first;
    write_input_var(file, inputs, name);
  }

  // Write output data.
  fprintf(file, "\n# Output data is stored here.\n");
  fprintf(file, "output = Object()\n");
  if (not user_config) {
    fprintf(file, "output.aerosols = Object()\n");
    fprintf(file, "output.aerosols.interstitial = Object()\n");
    fprintf(file, "output.aerosols.cloudy = Object()\n");
    for (int m = 0; m < aero_config.num_modes(); ++m) {
      auto mode = aero_config.aerosol_modes[m];
      fprintf(file, "output.aerosols.interstitial.%s = Object()\n",
              mode.name().c_str());
      fprintf(file, "output.aerosols.cloudy.%s = Object()\n",
              mode.name().c_str());
    }
    fprintf(file, "output.gases = Object()\n");
  }  // if not user config
  fprintf(file, "output.metrics = Object()\n");

  if (not user_config) {
    // Aerosol prognostics.
    for (int m = 0; m < aero_config.num_modes(); ++m) {
      auto mode = aero_config.aerosol_modes[m];
      for (int cloudy = 0; cloudy < 2; ++cloudy) {
        std::string prefix;
        if (cloudy) {
          prefix = "aerosols.cloudy.";
        } else {
          prefix = "aerosols.interstitial.";
        }
        auto num_mix_ratio_name =
            prefix + mode.name() + std::string(".number_mix_ratio");
        write_output_var(file, outputs, num_mix_ratio_name.c_str());
        auto species_for_mode = aero_config.aerosol_species_for_mode(m);
        for (auto species : species_for_mode) {
          auto sym = species.symbol();
          std::transform(sym.begin(), sym.end(), sym.begin(), ::tolower);
          auto species_name = prefix + mode.name() + std::string(".") + sym;
          write_output_var(file, outputs, species_name.c_str());
        }
      }
    }

    // Gases.
    for (int g = 0; g < aero_config.num_gases(); ++g) {
      auto gas = aero_config.gas_species[g];
      auto gas_name = std::string("gases.") + gas.symbol();
      std::transform(gas_name.begin(), gas_name.end(), gas_name.begin(),
                     ::tolower);
      write_output_var(file, outputs, gas_name.c_str());
    }
  }  // if not user config

  // Metrics.
  write_output_metrics(file, outputs);

  fclose(file);
}

}  // namespace skywalker
