#include "haero/modal_aerosol_config.hpp"
#include "skywalker.hpp"

namespace {

// Writes the given input variable to our Python module.
void write_input_var(FILE* file,
                     const std::vector<skywalker::InputData>& inputs,
                     const std::string& var_name) {
  fprintf(file, "input.%s = [", var_name.c_str());
  for (const auto& input : inputs) {
    auto var = input[var_name];
    fprintf(file, "%g, ", var);
  }
  fprintf(file, "]\n");
}

// Writes the given output variable to our Python module.
void write_output_var(FILE* file,
                      const std::vector<skywalker::OutputData>& outputs,
                      const std::string& var_name) {
  fprintf(file, "output.%s = [", var_name.c_str());
  for (const auto& output : outputs) {
    auto var = output[var_name];
    fprintf(file, "%g, ", var);
  }
  fprintf(file, "]\n");
}

}  // namespace

namespace skywalker {

void write_py_module(const std::vector<InputData>& inputs,
                     const std::vector<OutputData>& outputs,
                     const char* py_module_name) {
  auto aero_config = inputs[0].aero_config;

  FILE* file = fopen(py_module_name, "w");
  fprintf(file,
          "# This file was automatically generated by skywalker (HAERO "
          "edition).\n\n");
  fprintf(
      file,
      "# Object is just a dynamic container that stores input/output data.\n");
  fprintf(file, "class Object(object):\n");
  fprintf(file, "    pass\n\n");

  // Write input data.
  fprintf(file, "# Input is stored here.\n");
  fprintf(file, "input = Object()\n");
  fprintf(file, "input.atmosphere = Object()\n");
  fprintf(file, "input.aerosols = Object()\n");
  fprintf(file, "input.aerosols.interstitial = Object()\n");
  fprintf(file, "input.aerosols.cloudy = Object()\n");
  for (int m = 0; m < aero_config.num_modes(); ++m) {
    auto mode = aero_config.aerosol_modes[m];
    fprintf(file, "input.aerosols.interstitial.%s = Object()\n",
            mode.name().c_str());
    fprintf(file, "input.aerosols.cloudy.%s = Object()\n", mode.name().c_str());
  }
  fprintf(file, "input.gases = Object()\n");

  // Atmosphere state data.
  write_input_var(file, inputs, "atmosphere.temperature");
  write_input_var(file, inputs, "atmosphere.pressure");
  write_input_var(file, inputs, "atmosphere.relative_humidity");
  write_input_var(file, inputs, "atmosphere.height");
  write_input_var(file, inputs, "atmosphere.hydrostatic_dp");
  write_input_var(file, inputs, "atmosphere.planetary_boundary_layer_height");

  // Now we write out aerosol prognostics.
  for (int m = 0; m < aero_config.num_modes(); ++m) {
    auto mode = aero_config.aerosol_modes[m];
    for (int cloudy = 0; cloudy < 2; ++cloudy) {
      std::string prefix;
      if (cloudy) {
        prefix = "aerosols.cloudy.";
      } else {
        prefix = "aerosols.interstitial.";
      }
      auto number_conc_name =
          prefix + mode.name() + std::string(".number_conc");
      write_input_var(file, inputs, number_conc_name.c_str());
      auto species_for_mode = aero_config.aerosol_species_for_mode(m);
      for (auto species : species_for_mode) {
        auto sym = species.symbol();
        transform(sym.begin(), sym.end(), sym.begin(), ::tolower);
        auto species_name = prefix + mode.name() + std::string(".") + sym;
        write_input_var(file, inputs, species_name.c_str());
      }
    }
  }

  // Write out gases.
  for (int g = 0; g < aero_config.num_gases(); ++g) {
    auto gas = aero_config.gas_species[g];
    auto gas_name = std::string("gases.") + gas.symbol();
    std::transform(gas_name.begin(), gas_name.end(), gas_name.begin(),
                   ::tolower);
    write_input_var(file, inputs, gas_name.c_str());
  }

  // Write output data.
  fprintf(file, "\n# Output data is stored here.\n");
  fprintf(file, "output = Object()\n");
  fprintf(file, "output.atmosphere = Object()\n");
  fprintf(file, "output.aerosols = Object()\n");
  fprintf(file, "output.aerosols.interstitial = Object()\n");
  fprintf(file, "output.aerosols.cloudy = Object()\n");
  for (int m = 0; m < aero_config.num_modes(); ++m) {
    auto mode = aero_config.aerosol_modes[m];
    fprintf(file, "output.aerosols.interstitial.%s = Object()\n",
            mode.name().c_str());
    fprintf(file, "output.aerosols.cloudy.%s = Object()\n",
            mode.name().c_str());
  }
  fprintf(file, "output.gases = Object()\n");

  // Aerosol prognostics.
  for (int m = 0; m < aero_config.num_modes(); ++m) {
    auto mode = aero_config.aerosol_modes[m];
    for (int cloudy = 0; cloudy < 2; ++cloudy) {
      std::string prefix;
      if (cloudy) {
        prefix = "aerosols.cloudy.";
      } else {
        prefix = "aerosols.interstitial.";
      }
      auto number_conc_name =
          prefix + mode.name() + std::string(".number_conc");
      write_output_var(file, outputs, number_conc_name.c_str());
      auto species_for_mode = aero_config.aerosol_species_for_mode(m);
      for (auto species : species_for_mode) {
        auto sym = species.symbol();
        std::transform(sym.begin(), sym.end(), sym.begin(), ::tolower);
        auto species_name = prefix + mode.name() + std::string(".") + sym;
        write_output_var(file, outputs, species_name.c_str());
      }
    }
  }

  // Gases.
  for (int g = 0; g < aero_config.num_gases(); ++g) {
    auto gas = aero_config.gas_species[g];
    auto gas_name = std::string("gases.") + gas.symbol();
    std::transform(gas_name.begin(), gas_name.end(), gas_name.begin(),
                   ::tolower);
    write_output_var(file, outputs, gas_name.c_str());
  }

  fclose(file);
}

}  // namespace skywalker
