{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Overview Haero is a software library that can be used to implement a high-performance aerosol model. Haero defines a framework that allows one to create aerosol processes representing various stages of the aerosol lifecycle. These processes can be built in a way that allows them to run on CPUs or GPUs, using a single set of source code that leverages the Kokkos C++ library . The Installation guide shows you how to build and install Haero on your own machine or on a supported high-performance platform. The Glossary introduces the terminology we use to describe Haero and the physical concepts it attempts to represent. Look here if you see a term or symbol you don't understand. The Physics guide gives a brief description of the relevant governing equations that accommodate the particle size distributions inherent in aerosol modeling. The Library guide introduces the Haero library and its main abstraction, the aerosol process , which provides an elementaryu building block for implementing an aerosol model. The Processes guide contains brief descriptions of the aerosol processes included with Haero itself, with references to the original models they implement. The Driver guide describes Haero's standalone driver, which includes a one-dimensional hydrostatic dynamics package. The driver can be used to verify aerosol processes in a simple and self-contained context. In the Testing guide, we describe in general terms the methodology we use to test Haero and its aerosol processes. Acknowledgements Haero was developed by an interdisciplinary team consisting of aerosol and atmospheric researchers, applied mathematicians, and software engineers. It was created for the EAGLES project , an effort to improve the treatment of aerosols in E3SM , the Department of Energy's global climate model. The source code is available on GitHub . This effort was funded by the Office of Science's Biological and Environmental Research Program.","title":"Overview"},{"location":"#overview","text":"Haero is a software library that can be used to implement a high-performance aerosol model. Haero defines a framework that allows one to create aerosol processes representing various stages of the aerosol lifecycle. These processes can be built in a way that allows them to run on CPUs or GPUs, using a single set of source code that leverages the Kokkos C++ library . The Installation guide shows you how to build and install Haero on your own machine or on a supported high-performance platform. The Glossary introduces the terminology we use to describe Haero and the physical concepts it attempts to represent. Look here if you see a term or symbol you don't understand. The Physics guide gives a brief description of the relevant governing equations that accommodate the particle size distributions inherent in aerosol modeling. The Library guide introduces the Haero library and its main abstraction, the aerosol process , which provides an elementaryu building block for implementing an aerosol model. The Processes guide contains brief descriptions of the aerosol processes included with Haero itself, with references to the original models they implement. The Driver guide describes Haero's standalone driver, which includes a one-dimensional hydrostatic dynamics package. The driver can be used to verify aerosol processes in a simple and self-contained context. In the Testing guide, we describe in general terms the methodology we use to test Haero and its aerosol processes.","title":"Overview"},{"location":"#acknowledgements","text":"Haero was developed by an interdisciplinary team consisting of aerosol and atmospheric researchers, applied mathematicians, and software engineers. It was created for the EAGLES project , an effort to improve the treatment of aerosols in E3SM , the Department of Energy's global climate model. The source code is available on GitHub . This effort was funded by the Office of Science's Biological and Environmental Research Program.","title":"Acknowledgements"},{"location":"driver/","text":"The Haero Driver The standalone driver program haero_driver provides a simple way to explore the capabilities of Haero. It's a simple single-column model with a bundled one-dimensional dynamics package. With it, you can run single-column aerosol simulations perform statistical analysis on ensembles consisting of several columns conduct time-step convergence studies to build confidence in Haero's mathematical algorithms and their implementations select specific aerosol processes and parametrizations to examine in isolation, to debug or verify a given algorithm study how the aerosol processes interact with one-dimensional dynamics and other simplified physical process representations In this chapter we describe the driver and its capabilities. Column Dynamics We use a one-dimensional (vertical) atmosphere and tests of increasing complexity. Let \\(z=z(a,t)\\) denote the trajectory of the particle labeled \\(a\\) that arrives at physical position \\(z\\) at time \\(t\\) . The label \\(a\\) is the Lagrangian, or material, coordinate. Particle trajectories are defined by \\[\\begin{equation} \\label{traj} \\deriv{z}{t}(a,t) = w(z(a,t),t), \\end{equation}\\] where \\(w(z,t)\\) is the vertical velocity. In the following sections, it will be convenient to formulate \\ref{traj} in terms of the geopotential \\(\\phi(a,t) = gz(a,t)\\) , \\[\\begin{equation} \\label{geo_traj} \\deriv{\\phi}{t}(a,t) = gw\\left(\\frac{\\phi(a,t)}{g},t\\right). \\end{equation}\\] Adiabatic column dynamics are described by the 1D Euler equations for a moist atmosphere, \\[\\begin{align} \\totd{w} &= -g\\left(\\frac{1}{\\rho}\\partd{p}{\\phi} + 1\\right), \\label{momentum}\\\\ \\totd{\\rho} &= - g\\rho \\partd{w}{\\phi}, \\label{eq:continuity}\\\\ \\totd{\\theta_v} &= 0, \\label{eq:thermo},\\\\ \\totd{q_v} &= 0, \\label{eq:qv} \\end{align}\\] where \\(\\rho\\) is density, \\(p\\) is pressure, \\(\\theta_v\\) is the virtual potential temperature, and \\(q_v\\) is the water vapor mass mixing ratio. As in \\cite{Taylor2020}, we treat virtual potential temperature \\(\\theta_v\\) as a material invariant. The momentum, continuity, thermodynamic equation, and transport equation (respectfully) combine with \\ref{geo_traj} and the equation of state \\[\\begin{equation}\\label{eos} \\frac{p}{\\Pi} = \\rho R \\theta_v, \\end{equation}\\] to define the complete system. Above, \\(\\Pi = (p/p_{ref})^{\\kappa}\\) is the nondimensional Exner pressure, with constant \\(\\kappa = R/c_p\\) , where \\(R\\) is the dry air gas constant and \\(c_p\\) is the specific heat of dry air at constant pressure. We have 6 prognostic variables ( \\(\\phi, w, \\rho, \\theta_v, q_v, p\\) ), and 6 equations. The boundary conditions are \\(w(0,t) = w(z_{top},t) = 0\\) . The advantage of the Lagrangian frame of reference imposed by \\ref{geo_traj} is that the material derivative becomes an ordinary time derivative, \\(D/Dt = d/dt\\) . Hence, for the remainder of this note we simply use \\(d/dt\\) in our notation. We begin with an ansatz that the velocity has a simple form, \\[\\begin{equation}\\label{z_vel} w(z,t) = w_0\\sin\\frac{\\pi z}{z_{top}}\\sin \\frac{2\\pi t}{t_p}, \\end{equation}\\] where we have introduced parameters for the maximum velocity, \\(w_0\\) , the top of the model column, \\(z_{top}\\) , and the period of oscillation \\(t_p\\) . This velocity satisfies the boundary conditions and the initial condition, \\(w(z,0) = 0\\) . We assume that this velocity is valid for all time throughout the whole column, from \\(z=0\\) to \\(z=z_{top}\\) . In terms of the geopotential, \\ref{z_vel} becomes \\[\\begin{equation}\\label{eq:phi_vel} w(\\phi,t) = w_0 \\sin \\frac{\\pi \\phi}{g z_{top}}\\sin\\frac{2\\pi t}{t_p}. \\end{equation}\\] Since velocity is prescribed, it does not need to be prognosed. This eliminates \\ref{momentum} from our system of equations \\eqref{eq:1d}. Our goal is to derive the other variables associated with 1D motion in a non-hydrostatic column so that we have consistent dynamics and thermodynamics. Substituting \\ref{phi_vel} into \\ref{geo_traj}, we discover a separable ODE, \\[\\begin{align} \\deriv{\\phi}{t} &= gw_0\\sin\\frac{\\pi \\phi}{g z_{top}}\\sin\\frac{2\\pi t}{t_p},\\\\ \\Rightarrow \\int \\csc\\frac{\\pi \\phi}{g z_{top}}\\,d\\phi &= g w_0\\int\\sin\\frac{2\\pi t}{t_p}\\,dt, \\end{align}\\] whose solution is \\[\\begin{equation}\\label{phi_sol} \\phi(t) = \\frac{2gz_{top}}{\\pi}\\arctan\\left[\\tan\\frac{\\pi \\phi_0}{2g z_{top}}\\exp\\left(\\frac{w_0t_p}{z_{top}} \\sin^2 \\frac{\\pi t}{t_p}\\right)\\right]. \\end{equation}\\] ![Geopotential \\(\\phi(t)\\) for \\(\\phi_0 = gz_0\\) and \\(z_0\\) values listed in the legend, with parameters \\(w_0=5\\) , \\(T_{v0}=300\\) , \\(\\Gamma_v=0.01\\) , \\(z_{top}=20000\\) , \\(t_p=900\\) .]](images/geopotential_plot.pdf) We use \\ref{phi_vel} to find the divergence, which is required by the continuity equation \\ref{continuity} \\[\\begin{equation}\\label{div} \\partd{w}{\\phi}(\\phi,t) = \\frac{\\pi w_0}{g z_{top}}\\cos\\frac{\\pi \\phi(t)}{gz_{top}}\\sin\\frac{2\\pi t}{t_p}. \\end{equation}\\] Substituting \\ref{div} into \\ref{continuity}, we find another separable ODE: \\[\\begin{align} \\deriv{\\rho}{t} &= -\\rho \\left(\\frac{\\pi w_0}{z_{top}}\\cos\\frac{\\pi \\phi(t)}{g z_{top}}\\sin\\frac{2\\pi t}{t_p}\\right)\\\\ \\Rightarrow \\int \\frac{1}{\\rho}\\,d\\rho &= -\\frac{\\pi w_0}{z_{top}}\\cos\\frac{\\pi \\phi(t)}{z_{top}}\\int \\sin \\frac{2\\pi t}{t_p}\\,dt. \\end{align}\\] The solution is \\[\\begin{align} \\label{density} \\rho(\\phi(t),t) = \\rho_0(\\phi_0)\\exp\\left[\\frac{ w_0 t_p}{2z_{top}}\\left(\\cos\\frac{\\pi {\\phi}(t)}{gz_{top}}\\cos\\frac{2\\pi t}{t_p}-\\cos\\frac{\\pi {\\phi_0}}{gz_{top}}\\right)\\right]. \\end{align}\\] To find the pressure, we use \\ref{density} in \\ref{eos}: \\[\\begin{align} \\frac{p}{\\Pi} &= R\\rho(\\phi(t),t)\\theta_v(\\phi(t),t),\\notag \\\\ p(\\phi(t),t) &= \\left(p_{ref}^{-\\kappa} R \\rho(\\phi(t),t)\\theta_v(\\phi(t),t)\\right)^{1/(1-\\kappa)}.\\label{eq:pressure} \\end{align}\\] Physical interpretation Physically, the ansatz \\eqref{eq:z_vel} may be interpreted via \\ref{momentum} as defining the balance between buoyancy, the pressure gradient force, and gravity to be \\[\\begin{align} -g\\left(1 + \\frac{1}{\\rho}\\partd{p}{\\phi}\\right) &= \\deriv{w}{t}(\\phi,t), \\notag \\\\ &= \\frac{2\\pi w_0}{t_p}\\sin\\frac{\\pi\\phi}{gz_{top}}\\cos\\frac{2\\pi t}{t_p} + \\frac{\\pi w_0^2}{2z_{top}}\\sin\\frac{2\\pi\\phi}{gz_{top}}\\sin^2\\frac{2\\pi t}{t_p}, \\end{align}\\] where the right-hand side is the time derivative of \\ref{phi_vel}. It is most straightforward to derive this interpretation by decomposing the pressure into a constant, hydrostatically balanced reference state with a superimposed perturbation \\cite{KlempWilhelmson1978,Srivastava1967,SoongOgura1973} so that \\(p = \\overline{p} + p'\\) . Combining this decomposition (and similar treatment of temperature and density) with the equation of state leads to a formulation of the total pressure gradient as the background hydrostatic balance plus a perturbation due to nonhydrostatic buoyancy. In \\cite{KlempWilhelmson1978,Srivastava1967,SoongOgura1973} this arises as quadratic terms of the perturbation variables are neglected. It is interesting that a similar (though not equivalent\\footnote{Taylor et.~al.~\\cite{Taylor2020} retain the full form of the pressure gradient, without a linearization.}) term arises in \\cite{Taylor2020} as a result of the choice of a vertical mass coordinate based on hydrostatic pressure. Initialization Initial conditions are defined by stationary, \\(w(\\phi(0),0) = 0,\\) hydrostatic balance with a constant lapse rate in the virtual temperature profile, and exponential decay in the water vapor mixing ratio. The initial virtual temperature profile is defined by two parameters, \\(T_{0}\\) and \\(\\Gamma_v\\) (with default values 300K and 0.01 K/m, respectively), \\[\\begin{equation}\\label{tv} T_{v0}(z) = T_{0} - \\Gamma_v z. \\end{equation}\\] Using \\ref{tv} with \\(p=\\rho R T_v\\) , an equivalent form of the equation of state \\ref{eos}, the hydrostatic equation \\(\\partd{p}{z} = -\\rho g\\) , and separation of variables (again), we derive expressions that relate initial height to initial pressure: \\[\\begin{align} p_0(z) = \\begin{cases} p_{ref}\\exp\\left(\\frac{-g z}{R T_{0}}\\right) & \\Gamma_v = 0,\\\\[0.5em] p_{ref}\\, T_0^{-g/(R\\Gamma_v)}\\left(T_{0} - \\Gamma_v z\\right)^{g/(R\\Gamma_v)} & \\Gamma_v \\ne 0, \\end{cases} \\label{eq:p_of_z}\\\\[0.5em] z_0(p) = \\begin{cases} -\\frac{R T_{0}}{g}\\log\\frac{p}{p_{ref}} & \\Gamma_v = 0,\\\\[0.5em] \\frac{T_{0}}{\\Gamma_v}\\left(1 - \\left(\\frac{p}{p_{ref}}\\right)^{R\\Gamma_v/g}\\right) & \\Gamma \\ne 0. \\end{cases}\\label{eq:z_of_p} \\end{align}\\] It follows that the initial virtual potential temperature profile is defined as \\[\\begin{equation} \\theta_{v0}(z) = T_{v0}(z)\\left(\\frac{p_{ref}}{p_0(z)}\\right)^\\kappa. \\end{equation}\\] The initial water vapor mixing ratio profile is also defined by two parameters, \\(q_0\\) and \\(q_1\\) , with default values \\(q_0=0.015\\) kg H \\(_2\\) O / kg air and $q_1 = $ 1E-3 m \\(^{-1}\\) , as \\[\\begin{equation}\\label{init_qv} q_{v0}(z) = q_0e^{-q_1 z}. \\end{equation}\\] Initial densities are defined as \\[\\begin{equation} \\rho_0(z) = \\frac{p_0(z)}{R\\,T_{v0}(z)}. \\end{equation}\\] Discretized Column The Haero column is defined by first setting the required parameters using the haero::driver::AtmosphericConditions class. These include the model top \\(z_{top}\\) , maximum vertical velocity \\(w_0\\) , and velocity period \\(t_p\\) in \\ref{phi_vel}, the initial virtual temperature profile \\ref{tv}, and the initial water vapor mixing ratio profile \\ref{init_qv}. In the Haero driver, we emulate the vertical grid staggering used by the HOMME-NH dynamical core \\cite{Taylor2020}, which has \\(n_{lev}\\) levels and \\(n_{lev}+1\\) interfaces. Levels are indexed by integer values \\(k\\) , for \\(k=1,\\dotsc,n_{lev}\\) and interfaces are indexed by \\(k+1/2\\) , for \\(k=0,\\dotsc,n_{lev}\\) . In the haero::driver::HostDynamics class, geopotential and vertical velocity are defined at interfaces: \\[\\begin{align} \\phi_{k+1/2}(t) &= \\frac{2gz_{top}}{\\pi}\\arctan\\left[\\tan\\frac{\\pi \\phi_{k+1/2}(0)}{2g z_{top}}\\exp\\left(\\frac{w_0t_p}{2z_{top}} \\sin^2 \\frac{2\\pi t}{t_p}\\right)\\right], \\label{eq:phi_disc}\\\\ w_{k+1/2}(t) &= w_0 \\sin \\frac{\\pi \\phi_{k+1/2}(t)}{g z_{top}}\\sin\\frac{2\\pi t}{t_p}. \\label{eq:w_disc} \\end{align}\\] Similarly, density, virtual potential temperature, water vapor, and pressure are defined at level midpoints \\[\\begin{align} \\rho_k(t) &= \\rho_0(\\overline{\\phi_k}(0))\\exp\\left[\\frac{ w_0 t_p}{2z_{top}}\\left(\\cos\\frac{\\pi \\overline{\\phi_k}(t)}{gz_{top}}\\cos\\frac{2\\pi t}{t_p}-\\cos\\frac{\\pi \\overline{\\phi_{k}}(0)}{gz_{top}}\\right)\\right], \\label{eq:rho_disc}\\\\ \\theta_{vk}(t) &= \\theta_{v0}(\\overline{\\phi_k}(0)/g), \\label{eq:thetav_disc} \\\\ q_{vk}(t) &= q_{v0}(\\overline{\\phi_k}(0)/g), \\label{eq:qv_disc} \\\\ % p_k(t) &= \\left(p_0^{-\\kappa}R \\, \\rho_k(t)\\,\\left(\\theta_v\\right)_k(t)\\right)^{1/(1-\\kappa)}, p_k(t) &= \\left(p_{ref}^{-\\kappa} R \\rho_k(t)\\theta_{vk}(t)\\right)^{1/(1-\\kappa)}\\label{eq:p_disc} \\end{align}\\] where the constants \\(g = 9.8\\) m/s \\(^2\\) , \\(p_{ref} = 10^5\\) Pa, and \\(\\kappa = 0.286\\) ; the overline denotes an average, \\(\\overline{\\phi_k}(t) = (\\phi_{k-1/2}(t) + \\phi_{k+1/2}(t))/2\\) . Users may opt to initialize a column with uniform spacing in either height or pressure (at interfaces), or to specify their own height or pressure interfaces via an input .yaml file. The model top is defined by \\ref{z_of_p}. Unit tests verify the expected 2nd order convergence of the centered finite difference methods used by both HOMME-NH and the Haero driver, and that layer thicknesses sum to the correct values \\(z_{top}\\) and \\(p_{top}\\) , as shown in the figure below: Layer thickness Layer thickness in height units is computed directly as \\[\\begin{equation}\\label{z_thick} \\Delta z_k = \\left(\\phi_{k-1/2} - \\phi_{k+1/2}\\right)/g, \\end{equation}\\] which reflects the true thickness of a model level in our non-hydrostatic model. However, some legacy parameterizations require thickness defined in pressure units. To support these parameterizations, we compute hydrostatic_dp as a member of the HostDynamics class. This calculation begins by defining the hydrostatic pressure \\(p_H\\) at each interface, \\(p_{H,k+1/2} = p(\\phi_{k+1/2}/g)\\) using \\ref{z_of_p}. Then the layer thickness is computed as \\[\\begin{equation}\\label{p_thick} \\Delta p_{Hk} = p_{H,k+1/2} - p_{H,k-1/2}. \\end{equation}\\] Hydrostatic layer thickness Pressure thickness is computed via the hydrostatic approximation. The interface hydrostatic pressures \\(p_H\\) are stored as a private variable, to prevent users from mistaking them for the full non-hydrostatic pressure. Creating a Haero atmosphere The above dynamics are motivated by the input requirements of the various parameterizations. These are encapsulated by the haero::Atmosphere class, which requires temperature, pressure, height, and relative humidity data. We already have pressure and height. Temperature may be diagnosed using the approximation given by \\cite[eq.~(2.3)]{KlempWilhelmson1978}, \\[\\begin{equation}\\label{approx_temp} T_k(t) \\approx \\frac{\\theta_{vk}(t) ~ \\Pi_k(t)}{1+\\alpha_q ~ q_{vk}(t)}, \\end{equation}\\] with constant \\(\\alpha_q = 0.61\\) . We compute relative humidity as \\(s = q_v/q_{vsat}\\) , where \\(q_{vsat}\\) is the saturation mixing ratio. We use the Tetens equation to find \\(q_{vsat}\\) \\cite[eqn. (A1)]{SoongOgura1973}, \\begin{equation}\\label{eq:tetens} q_{vs}(T) = \\frac{380.042}{p}\\exp\\left(\\frac{15}{2}\\log(10) \\frac{T-273}{T-36}\\right). \\end{equation} Time Stepping The above dynamics are associated with the following tendencies , the right-hand sides of \\ref{geo_traj} and \\ref{1d} \\[\\begin{align} \\dot{w}(\\phi,t) \\equiv \\totd{w} &= \\frac{2\\pi w_0}{t_p}\\sin\\frac{\\pi\\phi}{gz_{top}}\\cos\\frac{2\\pi t}{t_p} + \\frac{\\pi w_0^2}{2z_{top}}\\sin\\frac{2\\pi\\phi}{gz_{top}}\\sin^2\\frac{2\\pi t}{t_p},\\\\ \\dot{\\phi}(\\phi,t) \\equiv \\totd{\\phi} &= gw_0 \\sin \\frac{\\pi \\phi}{g z_{top}}\\sin\\frac{2\\pi t}{t_p},\\\\ \\dot{\\rho}(\\phi, t, \\rho) \\equiv \\totd{\\rho} &= -\\rho \\frac{\\pi w_0}{z_{top}}\\cos\\frac{\\pi \\phi}{g z_{top}}\\sin\\frac{2\\pi t}{t_p},\\\\ \\dot{\\theta_v} \\equiv \\totd{\\theta_v} &= 0,\\\\ \\dot{q_v} \\equiv \\totd{q_v} &= 0, \\end{align}\\] where the dot denotes differentiation with respect to time. Simple microphysics A simple cloud model with warm-rain microphysics, often called \\emph{Kessler microphysics}, is summarized in \\cite[ch.~15]{RogersYau}, which references \\cite{Srivastava1967}. It introduces mass mixing ratio tracers for cloud liquid water \\(q_c\\) and rain water \\(q_r\\) and source terms for the dynamics equations. We use \\cite{SoongOgura1973,KlempWilhelmson1978} as additional references. We adapt this microphysics model here to match the HOMME-NH dynamics variables. The two new tracers are advected passively by the dynamics (without source and sink terms) in the same manner as water vapor, \\[\\begin{align} \\dot{q_c} \\equiv \\deriv{q_c}{t} &= 0,\\\\ \\dot{q_r} \\equiv \\deriv{q_r}{t} &= 0. \\end{align}\\] Microphysical parameterizations define approximate source and sink terms to correspond to a select (incomplete) set of physical processes, as described below. Vertical velocity The vertical velocity \\(w\\) is adjusted to account for loss of buoyancy due to the mass of suspended liquid water, \\[\\begin{equation} \\dot{w} \\pluseq -g(q_c+q_r). \\end{equation}\\] Evaporation and condensation Our first step assumes unsaturated air, \\(q_v \\le q_{vs}\\) , where \\(q_{vs}\\) is the saturation mixing ratio defined by \\ref{tetens} using the temperature computed by \\ref{approx_temp}, \\[\\begin{align} \\dot{q_v} &\\pluseq E_{cv} + E_{rv}, \\\\ \\dot{q_c} &\\minuseq E_{cv}, \\\\ \\dot{q_r} &\\minuseq E_{rv}, \\\\ \\dot{\\theta_v} &\\minuseq \\frac{L}{c_p \\Pi}(E_{cv} + E_{rv}), \\end{align}\\] where \\(E_{cv}\\) and \\(E_{rv}\\) denote the evaporation rates between cloud liquid/water vapor and rain/water vapor, respectively. \\[\\begin{equation}\\label{cloud2vapor_evap} E_{cv} = \\begin{cases} q_c & \\text{if } q_v < q_{vs} \\\\ 0 & \\text{otherwise}\\end{cases} \\end{equation}\\] \\[\\begin{equation} E_{rv} = \\begin{cases} \\frac{(1-q_v/q_{vs}) C_{vt} (\\rho q_r)^{0.525}}{\\rho 5.4\\text{E}5 + 4.1\\text{E}6/e_s(T)} & \\text{if } q_v < q_{vs} \\text{ and } q_c = 0 \\\\ 0 & \\text{otherwise}\\end{cases} \\end{equation}\\] The ventillation coefficient \\(C_{vt} = 1.6 + 5.7\\text{E-}2V_r^{3/2}\\) for rain falling at speed \\(V_r\\) relative to the air, and \\(e_s(T)\\) is the saturation vapor pressure for a planar liquid water surface at temperature \\(T\\) . The latter two values are approximated as \\cite[eqn.~(15))]{SoongOgura1973}, \\begin{align} V_r & = 36.34 (1\\text{E}3\\rho q_r)^{0.1364} \\text{ m/s},\\ e_s(T) & = 6.1094\\exp\\left( \\frac{17.625 (T-273)}{T-29.96} \\right)\\text{ hPa}. \\end{align} Warning The exponent 0.1364 in the fall velocity expression is as written in \\cite[eqn. (15)]{SoongOgura1973}; in \\cite[eqn.~(2.15)]{KlempWilhelmson1978} it's written as 0.1346. The authors of \\cite{KlempWilhelmson1978} modify the expression used in \\cite{SoongOgura1973} to include a reference density term (and make a similar modification to the ventilation coefficient). Since this modification is unrelated to the exponent, we have assumed that 0.1346 is a typographical error and we use the value from \\cite{SoongOgura1973} in this work. A second step \\cite[eqns.(A7)--(A10)]{SoongOgura1973} conducts an adjustment for supersaturated air, \\(q_v > q_{vs}\\) , after the time stepping procedure implied by \\ref{evap} is finished. Let these values be denoted by a star: \\(\\theta_v^*\\) , \\(q_v^*\\) , \\(q_c^*\\) , etc. Define the factor \\(r_1\\) , \\begin{equation} r_1 = \\left(1 + \\frac{237 a\\Pi q_{vs}^ }{(T^ -36)^2}\\frac{L}{c_p\\Pi} \\right)^{-1}. \\end{equation} Then the adjusted values are given as \\[\\begin{align} q_v &= q_{v}^* - r_1(q_v^*-q_{vs}^*),\\\\ \\theta_v & = \\left(\\theta^* + \\frac{Lr_1}{c_p\\Pi}(q_v^*-q_{vs}^*)\\right)\\left(1 + \\alpha_v q_v\\right),\\\\ q_c &= q_v^* + q_c^* - q_v. \\end{align}\\] Autoconversion Autoconversion of cloud liquid into rain only occurs in the presence of sufficient cloud water droplets. Here, \"sufficient\" is defined as greater than a constant critical value, \\(q_c^{(crit)}\\) , and \\cite[eqn.~(12)]{Srivastava1967} \\[\\begin{align} \\dot{q_c} &\\minuseq \\alpha_{auto}(q_c - q_c^{(crit)})_+,\\\\ \\dot{q_r} &\\pluseq \\alpha_{auto}(q_c - q_c^{(crit)})_+, \\end{align}\\] where \\(\\alpha_{auto}\\) [1/s] is the inverse of the autoconversion time scale and \\(q_c^{(crit)}\\) is a user-defined parameter. In \\cite{SoongOgura1973}, \\(\\alpha_{auto}=1\\text{E-3}\\) s \\(^{-1}\\) and \\(q_c^{(crit)} = 1\\text{E-3}\\) . Accretion Accretion describes the capture of cloud water droplets by rainwater droplets. As in \\cite{SoongOgura1973,KlempWilhelmson1978}, we use \\[\\begin{align} \\dot{q_c} &\\minuseq \\alpha_{accr}q_cq_r^{7/8}, \\\\ \\dot{q_r} &\\pluseq \\alpha_{accr} q_c q_r^{7/8}, \\end{align}\\] with \\(\\alpha_{accr} = 2.2\\) . Rainwater sedimentation \\[\\begin{equation} \\dot{q_r} \\minuseq \\frac{1}{\\rho}\\partd{}{z}(\\rho V_rq_r) \\end{equation}\\] At the model top, this term is zero. Turbulent mixing We modify sub-grid scale turbulence mode of \\cite{KlempWilhelmson1978} to use a simple Smagorinsky turbulent eddy mixing coefficient, \\[\\begin{equation} K_m = \\sqrt{2}\\left(\\frac{7l}{50}\\right)^2 \\abs{\\partd{w}{z}}. \\end{equation}\\] The additional source terms are \\cite[eqns.~(3.15)--(3.16)]{KlempWilhelmson1978} \\[\\begin{align} \\dot{w} &\\pluseq 2 \\partd{}{z}\\left(K_m \\partd{w}{z}\\right) - \\frac{20}{3 l^2}K_m\\partd{K_m}{z},\\\\ \\dot{q_v} &\\pluseq 3\\partd{}{z}\\left(K_m\\partd{q_v}{z}\\right), \\\\ \\dot{q_c} &\\pluseq 3\\partd{}{z}\\left(K_m\\partd{q_c}{z}\\right), \\\\ \\dot{\\theta} &\\pluseq 3\\partd{}{z}\\left(K_m\\partd{\\theta}{z}\\right). \\end{align}\\] Embedded parameterization","title":"The Haero Driver"},{"location":"driver/#the-haero-driver","text":"The standalone driver program haero_driver provides a simple way to explore the capabilities of Haero. It's a simple single-column model with a bundled one-dimensional dynamics package. With it, you can run single-column aerosol simulations perform statistical analysis on ensembles consisting of several columns conduct time-step convergence studies to build confidence in Haero's mathematical algorithms and their implementations select specific aerosol processes and parametrizations to examine in isolation, to debug or verify a given algorithm study how the aerosol processes interact with one-dimensional dynamics and other simplified physical process representations In this chapter we describe the driver and its capabilities.","title":"The Haero Driver"},{"location":"driver/#column-dynamics","text":"We use a one-dimensional (vertical) atmosphere and tests of increasing complexity. Let \\(z=z(a,t)\\) denote the trajectory of the particle labeled \\(a\\) that arrives at physical position \\(z\\) at time \\(t\\) . The label \\(a\\) is the Lagrangian, or material, coordinate. Particle trajectories are defined by \\[\\begin{equation} \\label{traj} \\deriv{z}{t}(a,t) = w(z(a,t),t), \\end{equation}\\] where \\(w(z,t)\\) is the vertical velocity. In the following sections, it will be convenient to formulate \\ref{traj} in terms of the geopotential \\(\\phi(a,t) = gz(a,t)\\) , \\[\\begin{equation} \\label{geo_traj} \\deriv{\\phi}{t}(a,t) = gw\\left(\\frac{\\phi(a,t)}{g},t\\right). \\end{equation}\\] Adiabatic column dynamics are described by the 1D Euler equations for a moist atmosphere, \\[\\begin{align} \\totd{w} &= -g\\left(\\frac{1}{\\rho}\\partd{p}{\\phi} + 1\\right), \\label{momentum}\\\\ \\totd{\\rho} &= - g\\rho \\partd{w}{\\phi}, \\label{eq:continuity}\\\\ \\totd{\\theta_v} &= 0, \\label{eq:thermo},\\\\ \\totd{q_v} &= 0, \\label{eq:qv} \\end{align}\\] where \\(\\rho\\) is density, \\(p\\) is pressure, \\(\\theta_v\\) is the virtual potential temperature, and \\(q_v\\) is the water vapor mass mixing ratio. As in \\cite{Taylor2020}, we treat virtual potential temperature \\(\\theta_v\\) as a material invariant. The momentum, continuity, thermodynamic equation, and transport equation (respectfully) combine with \\ref{geo_traj} and the equation of state \\[\\begin{equation}\\label{eos} \\frac{p}{\\Pi} = \\rho R \\theta_v, \\end{equation}\\] to define the complete system. Above, \\(\\Pi = (p/p_{ref})^{\\kappa}\\) is the nondimensional Exner pressure, with constant \\(\\kappa = R/c_p\\) , where \\(R\\) is the dry air gas constant and \\(c_p\\) is the specific heat of dry air at constant pressure. We have 6 prognostic variables ( \\(\\phi, w, \\rho, \\theta_v, q_v, p\\) ), and 6 equations. The boundary conditions are \\(w(0,t) = w(z_{top},t) = 0\\) . The advantage of the Lagrangian frame of reference imposed by \\ref{geo_traj} is that the material derivative becomes an ordinary time derivative, \\(D/Dt = d/dt\\) . Hence, for the remainder of this note we simply use \\(d/dt\\) in our notation. We begin with an ansatz that the velocity has a simple form, \\[\\begin{equation}\\label{z_vel} w(z,t) = w_0\\sin\\frac{\\pi z}{z_{top}}\\sin \\frac{2\\pi t}{t_p}, \\end{equation}\\] where we have introduced parameters for the maximum velocity, \\(w_0\\) , the top of the model column, \\(z_{top}\\) , and the period of oscillation \\(t_p\\) . This velocity satisfies the boundary conditions and the initial condition, \\(w(z,0) = 0\\) . We assume that this velocity is valid for all time throughout the whole column, from \\(z=0\\) to \\(z=z_{top}\\) . In terms of the geopotential, \\ref{z_vel} becomes \\[\\begin{equation}\\label{eq:phi_vel} w(\\phi,t) = w_0 \\sin \\frac{\\pi \\phi}{g z_{top}}\\sin\\frac{2\\pi t}{t_p}. \\end{equation}\\] Since velocity is prescribed, it does not need to be prognosed. This eliminates \\ref{momentum} from our system of equations \\eqref{eq:1d}. Our goal is to derive the other variables associated with 1D motion in a non-hydrostatic column so that we have consistent dynamics and thermodynamics. Substituting \\ref{phi_vel} into \\ref{geo_traj}, we discover a separable ODE, \\[\\begin{align} \\deriv{\\phi}{t} &= gw_0\\sin\\frac{\\pi \\phi}{g z_{top}}\\sin\\frac{2\\pi t}{t_p},\\\\ \\Rightarrow \\int \\csc\\frac{\\pi \\phi}{g z_{top}}\\,d\\phi &= g w_0\\int\\sin\\frac{2\\pi t}{t_p}\\,dt, \\end{align}\\] whose solution is \\[\\begin{equation}\\label{phi_sol} \\phi(t) = \\frac{2gz_{top}}{\\pi}\\arctan\\left[\\tan\\frac{\\pi \\phi_0}{2g z_{top}}\\exp\\left(\\frac{w_0t_p}{z_{top}} \\sin^2 \\frac{\\pi t}{t_p}\\right)\\right]. \\end{equation}\\] ![Geopotential \\(\\phi(t)\\) for \\(\\phi_0 = gz_0\\) and \\(z_0\\) values listed in the legend, with parameters \\(w_0=5\\) , \\(T_{v0}=300\\) , \\(\\Gamma_v=0.01\\) , \\(z_{top}=20000\\) , \\(t_p=900\\) .]](images/geopotential_plot.pdf) We use \\ref{phi_vel} to find the divergence, which is required by the continuity equation \\ref{continuity} \\[\\begin{equation}\\label{div} \\partd{w}{\\phi}(\\phi,t) = \\frac{\\pi w_0}{g z_{top}}\\cos\\frac{\\pi \\phi(t)}{gz_{top}}\\sin\\frac{2\\pi t}{t_p}. \\end{equation}\\] Substituting \\ref{div} into \\ref{continuity}, we find another separable ODE: \\[\\begin{align} \\deriv{\\rho}{t} &= -\\rho \\left(\\frac{\\pi w_0}{z_{top}}\\cos\\frac{\\pi \\phi(t)}{g z_{top}}\\sin\\frac{2\\pi t}{t_p}\\right)\\\\ \\Rightarrow \\int \\frac{1}{\\rho}\\,d\\rho &= -\\frac{\\pi w_0}{z_{top}}\\cos\\frac{\\pi \\phi(t)}{z_{top}}\\int \\sin \\frac{2\\pi t}{t_p}\\,dt. \\end{align}\\] The solution is \\[\\begin{align} \\label{density} \\rho(\\phi(t),t) = \\rho_0(\\phi_0)\\exp\\left[\\frac{ w_0 t_p}{2z_{top}}\\left(\\cos\\frac{\\pi {\\phi}(t)}{gz_{top}}\\cos\\frac{2\\pi t}{t_p}-\\cos\\frac{\\pi {\\phi_0}}{gz_{top}}\\right)\\right]. \\end{align}\\] To find the pressure, we use \\ref{density} in \\ref{eos}: \\[\\begin{align} \\frac{p}{\\Pi} &= R\\rho(\\phi(t),t)\\theta_v(\\phi(t),t),\\notag \\\\ p(\\phi(t),t) &= \\left(p_{ref}^{-\\kappa} R \\rho(\\phi(t),t)\\theta_v(\\phi(t),t)\\right)^{1/(1-\\kappa)}.\\label{eq:pressure} \\end{align}\\]","title":"Column Dynamics"},{"location":"driver/#physical-interpretation","text":"Physically, the ansatz \\eqref{eq:z_vel} may be interpreted via \\ref{momentum} as defining the balance between buoyancy, the pressure gradient force, and gravity to be \\[\\begin{align} -g\\left(1 + \\frac{1}{\\rho}\\partd{p}{\\phi}\\right) &= \\deriv{w}{t}(\\phi,t), \\notag \\\\ &= \\frac{2\\pi w_0}{t_p}\\sin\\frac{\\pi\\phi}{gz_{top}}\\cos\\frac{2\\pi t}{t_p} + \\frac{\\pi w_0^2}{2z_{top}}\\sin\\frac{2\\pi\\phi}{gz_{top}}\\sin^2\\frac{2\\pi t}{t_p}, \\end{align}\\] where the right-hand side is the time derivative of \\ref{phi_vel}. It is most straightforward to derive this interpretation by decomposing the pressure into a constant, hydrostatically balanced reference state with a superimposed perturbation \\cite{KlempWilhelmson1978,Srivastava1967,SoongOgura1973} so that \\(p = \\overline{p} + p'\\) . Combining this decomposition (and similar treatment of temperature and density) with the equation of state leads to a formulation of the total pressure gradient as the background hydrostatic balance plus a perturbation due to nonhydrostatic buoyancy. In \\cite{KlempWilhelmson1978,Srivastava1967,SoongOgura1973} this arises as quadratic terms of the perturbation variables are neglected. It is interesting that a similar (though not equivalent\\footnote{Taylor et.~al.~\\cite{Taylor2020} retain the full form of the pressure gradient, without a linearization.}) term arises in \\cite{Taylor2020} as a result of the choice of a vertical mass coordinate based on hydrostatic pressure.","title":"Physical interpretation"},{"location":"driver/#initialization","text":"Initial conditions are defined by stationary, \\(w(\\phi(0),0) = 0,\\) hydrostatic balance with a constant lapse rate in the virtual temperature profile, and exponential decay in the water vapor mixing ratio. The initial virtual temperature profile is defined by two parameters, \\(T_{0}\\) and \\(\\Gamma_v\\) (with default values 300K and 0.01 K/m, respectively), \\[\\begin{equation}\\label{tv} T_{v0}(z) = T_{0} - \\Gamma_v z. \\end{equation}\\] Using \\ref{tv} with \\(p=\\rho R T_v\\) , an equivalent form of the equation of state \\ref{eos}, the hydrostatic equation \\(\\partd{p}{z} = -\\rho g\\) , and separation of variables (again), we derive expressions that relate initial height to initial pressure: \\[\\begin{align} p_0(z) = \\begin{cases} p_{ref}\\exp\\left(\\frac{-g z}{R T_{0}}\\right) & \\Gamma_v = 0,\\\\[0.5em] p_{ref}\\, T_0^{-g/(R\\Gamma_v)}\\left(T_{0} - \\Gamma_v z\\right)^{g/(R\\Gamma_v)} & \\Gamma_v \\ne 0, \\end{cases} \\label{eq:p_of_z}\\\\[0.5em] z_0(p) = \\begin{cases} -\\frac{R T_{0}}{g}\\log\\frac{p}{p_{ref}} & \\Gamma_v = 0,\\\\[0.5em] \\frac{T_{0}}{\\Gamma_v}\\left(1 - \\left(\\frac{p}{p_{ref}}\\right)^{R\\Gamma_v/g}\\right) & \\Gamma \\ne 0. \\end{cases}\\label{eq:z_of_p} \\end{align}\\] It follows that the initial virtual potential temperature profile is defined as \\[\\begin{equation} \\theta_{v0}(z) = T_{v0}(z)\\left(\\frac{p_{ref}}{p_0(z)}\\right)^\\kappa. \\end{equation}\\] The initial water vapor mixing ratio profile is also defined by two parameters, \\(q_0\\) and \\(q_1\\) , with default values \\(q_0=0.015\\) kg H \\(_2\\) O / kg air and $q_1 = $ 1E-3 m \\(^{-1}\\) , as \\[\\begin{equation}\\label{init_qv} q_{v0}(z) = q_0e^{-q_1 z}. \\end{equation}\\] Initial densities are defined as \\[\\begin{equation} \\rho_0(z) = \\frac{p_0(z)}{R\\,T_{v0}(z)}. \\end{equation}\\]","title":"Initialization"},{"location":"driver/#discretized-column","text":"The Haero column is defined by first setting the required parameters using the haero::driver::AtmosphericConditions class. These include the model top \\(z_{top}\\) , maximum vertical velocity \\(w_0\\) , and velocity period \\(t_p\\) in \\ref{phi_vel}, the initial virtual temperature profile \\ref{tv}, and the initial water vapor mixing ratio profile \\ref{init_qv}. In the Haero driver, we emulate the vertical grid staggering used by the HOMME-NH dynamical core \\cite{Taylor2020}, which has \\(n_{lev}\\) levels and \\(n_{lev}+1\\) interfaces. Levels are indexed by integer values \\(k\\) , for \\(k=1,\\dotsc,n_{lev}\\) and interfaces are indexed by \\(k+1/2\\) , for \\(k=0,\\dotsc,n_{lev}\\) . In the haero::driver::HostDynamics class, geopotential and vertical velocity are defined at interfaces: \\[\\begin{align} \\phi_{k+1/2}(t) &= \\frac{2gz_{top}}{\\pi}\\arctan\\left[\\tan\\frac{\\pi \\phi_{k+1/2}(0)}{2g z_{top}}\\exp\\left(\\frac{w_0t_p}{2z_{top}} \\sin^2 \\frac{2\\pi t}{t_p}\\right)\\right], \\label{eq:phi_disc}\\\\ w_{k+1/2}(t) &= w_0 \\sin \\frac{\\pi \\phi_{k+1/2}(t)}{g z_{top}}\\sin\\frac{2\\pi t}{t_p}. \\label{eq:w_disc} \\end{align}\\] Similarly, density, virtual potential temperature, water vapor, and pressure are defined at level midpoints \\[\\begin{align} \\rho_k(t) &= \\rho_0(\\overline{\\phi_k}(0))\\exp\\left[\\frac{ w_0 t_p}{2z_{top}}\\left(\\cos\\frac{\\pi \\overline{\\phi_k}(t)}{gz_{top}}\\cos\\frac{2\\pi t}{t_p}-\\cos\\frac{\\pi \\overline{\\phi_{k}}(0)}{gz_{top}}\\right)\\right], \\label{eq:rho_disc}\\\\ \\theta_{vk}(t) &= \\theta_{v0}(\\overline{\\phi_k}(0)/g), \\label{eq:thetav_disc} \\\\ q_{vk}(t) &= q_{v0}(\\overline{\\phi_k}(0)/g), \\label{eq:qv_disc} \\\\ % p_k(t) &= \\left(p_0^{-\\kappa}R \\, \\rho_k(t)\\,\\left(\\theta_v\\right)_k(t)\\right)^{1/(1-\\kappa)}, p_k(t) &= \\left(p_{ref}^{-\\kappa} R \\rho_k(t)\\theta_{vk}(t)\\right)^{1/(1-\\kappa)}\\label{eq:p_disc} \\end{align}\\] where the constants \\(g = 9.8\\) m/s \\(^2\\) , \\(p_{ref} = 10^5\\) Pa, and \\(\\kappa = 0.286\\) ; the overline denotes an average, \\(\\overline{\\phi_k}(t) = (\\phi_{k-1/2}(t) + \\phi_{k+1/2}(t))/2\\) . Users may opt to initialize a column with uniform spacing in either height or pressure (at interfaces), or to specify their own height or pressure interfaces via an input .yaml file. The model top is defined by \\ref{z_of_p}. Unit tests verify the expected 2nd order convergence of the centered finite difference methods used by both HOMME-NH and the Haero driver, and that layer thicknesses sum to the correct values \\(z_{top}\\) and \\(p_{top}\\) , as shown in the figure below:","title":"Discretized Column"},{"location":"driver/#layer-thickness","text":"Layer thickness in height units is computed directly as \\[\\begin{equation}\\label{z_thick} \\Delta z_k = \\left(\\phi_{k-1/2} - \\phi_{k+1/2}\\right)/g, \\end{equation}\\] which reflects the true thickness of a model level in our non-hydrostatic model. However, some legacy parameterizations require thickness defined in pressure units. To support these parameterizations, we compute hydrostatic_dp as a member of the HostDynamics class. This calculation begins by defining the hydrostatic pressure \\(p_H\\) at each interface, \\(p_{H,k+1/2} = p(\\phi_{k+1/2}/g)\\) using \\ref{z_of_p}. Then the layer thickness is computed as \\[\\begin{equation}\\label{p_thick} \\Delta p_{Hk} = p_{H,k+1/2} - p_{H,k-1/2}. \\end{equation}\\] Hydrostatic layer thickness Pressure thickness is computed via the hydrostatic approximation. The interface hydrostatic pressures \\(p_H\\) are stored as a private variable, to prevent users from mistaking them for the full non-hydrostatic pressure.","title":"Layer thickness"},{"location":"driver/#creating-a-haero-atmosphere","text":"The above dynamics are motivated by the input requirements of the various parameterizations. These are encapsulated by the haero::Atmosphere class, which requires temperature, pressure, height, and relative humidity data. We already have pressure and height. Temperature may be diagnosed using the approximation given by \\cite[eq.~(2.3)]{KlempWilhelmson1978}, \\[\\begin{equation}\\label{approx_temp} T_k(t) \\approx \\frac{\\theta_{vk}(t) ~ \\Pi_k(t)}{1+\\alpha_q ~ q_{vk}(t)}, \\end{equation}\\] with constant \\(\\alpha_q = 0.61\\) . We compute relative humidity as \\(s = q_v/q_{vsat}\\) , where \\(q_{vsat}\\) is the saturation mixing ratio. We use the Tetens equation to find \\(q_{vsat}\\) \\cite[eqn. (A1)]{SoongOgura1973}, \\begin{equation}\\label{eq:tetens} q_{vs}(T) = \\frac{380.042}{p}\\exp\\left(\\frac{15}{2}\\log(10) \\frac{T-273}{T-36}\\right). \\end{equation}","title":"Creating a Haero atmosphere"},{"location":"driver/#time-stepping","text":"The above dynamics are associated with the following tendencies , the right-hand sides of \\ref{geo_traj} and \\ref{1d} \\[\\begin{align} \\dot{w}(\\phi,t) \\equiv \\totd{w} &= \\frac{2\\pi w_0}{t_p}\\sin\\frac{\\pi\\phi}{gz_{top}}\\cos\\frac{2\\pi t}{t_p} + \\frac{\\pi w_0^2}{2z_{top}}\\sin\\frac{2\\pi\\phi}{gz_{top}}\\sin^2\\frac{2\\pi t}{t_p},\\\\ \\dot{\\phi}(\\phi,t) \\equiv \\totd{\\phi} &= gw_0 \\sin \\frac{\\pi \\phi}{g z_{top}}\\sin\\frac{2\\pi t}{t_p},\\\\ \\dot{\\rho}(\\phi, t, \\rho) \\equiv \\totd{\\rho} &= -\\rho \\frac{\\pi w_0}{z_{top}}\\cos\\frac{\\pi \\phi}{g z_{top}}\\sin\\frac{2\\pi t}{t_p},\\\\ \\dot{\\theta_v} \\equiv \\totd{\\theta_v} &= 0,\\\\ \\dot{q_v} \\equiv \\totd{q_v} &= 0, \\end{align}\\] where the dot denotes differentiation with respect to time.","title":"Time Stepping"},{"location":"driver/#simple-microphysics","text":"A simple cloud model with warm-rain microphysics, often called \\emph{Kessler microphysics}, is summarized in \\cite[ch.~15]{RogersYau}, which references \\cite{Srivastava1967}. It introduces mass mixing ratio tracers for cloud liquid water \\(q_c\\) and rain water \\(q_r\\) and source terms for the dynamics equations. We use \\cite{SoongOgura1973,KlempWilhelmson1978} as additional references. We adapt this microphysics model here to match the HOMME-NH dynamics variables. The two new tracers are advected passively by the dynamics (without source and sink terms) in the same manner as water vapor, \\[\\begin{align} \\dot{q_c} \\equiv \\deriv{q_c}{t} &= 0,\\\\ \\dot{q_r} \\equiv \\deriv{q_r}{t} &= 0. \\end{align}\\] Microphysical parameterizations define approximate source and sink terms to correspond to a select (incomplete) set of physical processes, as described below.","title":"Simple microphysics"},{"location":"driver/#vertical-velocity","text":"The vertical velocity \\(w\\) is adjusted to account for loss of buoyancy due to the mass of suspended liquid water, \\[\\begin{equation} \\dot{w} \\pluseq -g(q_c+q_r). \\end{equation}\\]","title":"Vertical velocity"},{"location":"driver/#evaporation-and-condensation","text":"Our first step assumes unsaturated air, \\(q_v \\le q_{vs}\\) , where \\(q_{vs}\\) is the saturation mixing ratio defined by \\ref{tetens} using the temperature computed by \\ref{approx_temp}, \\[\\begin{align} \\dot{q_v} &\\pluseq E_{cv} + E_{rv}, \\\\ \\dot{q_c} &\\minuseq E_{cv}, \\\\ \\dot{q_r} &\\minuseq E_{rv}, \\\\ \\dot{\\theta_v} &\\minuseq \\frac{L}{c_p \\Pi}(E_{cv} + E_{rv}), \\end{align}\\] where \\(E_{cv}\\) and \\(E_{rv}\\) denote the evaporation rates between cloud liquid/water vapor and rain/water vapor, respectively. \\[\\begin{equation}\\label{cloud2vapor_evap} E_{cv} = \\begin{cases} q_c & \\text{if } q_v < q_{vs} \\\\ 0 & \\text{otherwise}\\end{cases} \\end{equation}\\] \\[\\begin{equation} E_{rv} = \\begin{cases} \\frac{(1-q_v/q_{vs}) C_{vt} (\\rho q_r)^{0.525}}{\\rho 5.4\\text{E}5 + 4.1\\text{E}6/e_s(T)} & \\text{if } q_v < q_{vs} \\text{ and } q_c = 0 \\\\ 0 & \\text{otherwise}\\end{cases} \\end{equation}\\] The ventillation coefficient \\(C_{vt} = 1.6 + 5.7\\text{E-}2V_r^{3/2}\\) for rain falling at speed \\(V_r\\) relative to the air, and \\(e_s(T)\\) is the saturation vapor pressure for a planar liquid water surface at temperature \\(T\\) . The latter two values are approximated as \\cite[eqn.~(15))]{SoongOgura1973}, \\begin{align} V_r & = 36.34 (1\\text{E}3\\rho q_r)^{0.1364} \\text{ m/s},\\ e_s(T) & = 6.1094\\exp\\left( \\frac{17.625 (T-273)}{T-29.96} \\right)\\text{ hPa}. \\end{align} Warning The exponent 0.1364 in the fall velocity expression is as written in \\cite[eqn. (15)]{SoongOgura1973}; in \\cite[eqn.~(2.15)]{KlempWilhelmson1978} it's written as 0.1346. The authors of \\cite{KlempWilhelmson1978} modify the expression used in \\cite{SoongOgura1973} to include a reference density term (and make a similar modification to the ventilation coefficient). Since this modification is unrelated to the exponent, we have assumed that 0.1346 is a typographical error and we use the value from \\cite{SoongOgura1973} in this work. A second step \\cite[eqns.(A7)--(A10)]{SoongOgura1973} conducts an adjustment for supersaturated air, \\(q_v > q_{vs}\\) , after the time stepping procedure implied by \\ref{evap} is finished. Let these values be denoted by a star: \\(\\theta_v^*\\) , \\(q_v^*\\) , \\(q_c^*\\) , etc. Define the factor \\(r_1\\) , \\begin{equation} r_1 = \\left(1 + \\frac{237 a\\Pi q_{vs}^ }{(T^ -36)^2}\\frac{L}{c_p\\Pi} \\right)^{-1}. \\end{equation} Then the adjusted values are given as \\[\\begin{align} q_v &= q_{v}^* - r_1(q_v^*-q_{vs}^*),\\\\ \\theta_v & = \\left(\\theta^* + \\frac{Lr_1}{c_p\\Pi}(q_v^*-q_{vs}^*)\\right)\\left(1 + \\alpha_v q_v\\right),\\\\ q_c &= q_v^* + q_c^* - q_v. \\end{align}\\]","title":"Evaporation and condensation"},{"location":"driver/#autoconversion","text":"Autoconversion of cloud liquid into rain only occurs in the presence of sufficient cloud water droplets. Here, \"sufficient\" is defined as greater than a constant critical value, \\(q_c^{(crit)}\\) , and \\cite[eqn.~(12)]{Srivastava1967} \\[\\begin{align} \\dot{q_c} &\\minuseq \\alpha_{auto}(q_c - q_c^{(crit)})_+,\\\\ \\dot{q_r} &\\pluseq \\alpha_{auto}(q_c - q_c^{(crit)})_+, \\end{align}\\] where \\(\\alpha_{auto}\\) [1/s] is the inverse of the autoconversion time scale and \\(q_c^{(crit)}\\) is a user-defined parameter. In \\cite{SoongOgura1973}, \\(\\alpha_{auto}=1\\text{E-3}\\) s \\(^{-1}\\) and \\(q_c^{(crit)} = 1\\text{E-3}\\) .","title":"Autoconversion"},{"location":"driver/#accretion","text":"Accretion describes the capture of cloud water droplets by rainwater droplets. As in \\cite{SoongOgura1973,KlempWilhelmson1978}, we use \\[\\begin{align} \\dot{q_c} &\\minuseq \\alpha_{accr}q_cq_r^{7/8}, \\\\ \\dot{q_r} &\\pluseq \\alpha_{accr} q_c q_r^{7/8}, \\end{align}\\] with \\(\\alpha_{accr} = 2.2\\) .","title":"Accretion"},{"location":"driver/#rainwater-sedimentation","text":"\\[\\begin{equation} \\dot{q_r} \\minuseq \\frac{1}{\\rho}\\partd{}{z}(\\rho V_rq_r) \\end{equation}\\] At the model top, this term is zero.","title":"Rainwater sedimentation"},{"location":"driver/#turbulent-mixing","text":"We modify sub-grid scale turbulence mode of \\cite{KlempWilhelmson1978} to use a simple Smagorinsky turbulent eddy mixing coefficient, \\[\\begin{equation} K_m = \\sqrt{2}\\left(\\frac{7l}{50}\\right)^2 \\abs{\\partd{w}{z}}. \\end{equation}\\] The additional source terms are \\cite[eqns.~(3.15)--(3.16)]{KlempWilhelmson1978} \\[\\begin{align} \\dot{w} &\\pluseq 2 \\partd{}{z}\\left(K_m \\partd{w}{z}\\right) - \\frac{20}{3 l^2}K_m\\partd{K_m}{z},\\\\ \\dot{q_v} &\\pluseq 3\\partd{}{z}\\left(K_m\\partd{q_v}{z}\\right), \\\\ \\dot{q_c} &\\pluseq 3\\partd{}{z}\\left(K_m\\partd{q_c}{z}\\right), \\\\ \\dot{\\theta} &\\pluseq 3\\partd{}{z}\\left(K_m\\partd{\\theta}{z}\\right). \\end{align}\\]","title":"Turbulent mixing"},{"location":"driver/#embedded-parameterization","text":"","title":"Embedded parameterization"},{"location":"glossary/","text":"\\[ \\newcommand{\\dsub}[1]{_{_{#1}}} \\newcommand{\\specidx}{L} \\newcommand{\\amass}[1]{q\\dsub{m,#1,i}} \\newcommand{\\vmass}[1]{q\\dsub{v,#1}} \\newcommand{\\mw}[1]{M\\dsub{w,#1}} \\newcommand{\\rsag}{\\rm H_2SO_4} \\newcommand{\\sag}{H_2SO_4} \\newcommand{\\rasf}{\\rm SO_4} \\newcommand{\\asf}{SO_4} \\] Glossary This section contains definitions of important terms and mathematical quantities used in Haero. Terminology Here are terms you may encounter when reading about Haero's aerosol processes. Cloud Condensation Nuclei (CCN) : Precursors : Secondary Aerosols : Mathematical Notation The following symbols are used in equations within Haero's aerosol processes. Relevant units are given in square brackets next to their symbols. [-] indicates that a quantity is unitless. \\(T\\) : air temperature [K] \\(p\\) : air pressure [Pa] \\(M_s\\) : molecular weight of chemical species \\(s\\) [kg/mol]. Note that \\(M_{air}\\) = 28.966 \\(~kg~\\) \\cdot \\(~kmol\\) ^{-1}$ in E3SM. \\(\\mathscr{R}\\) : universal gas constant [J/mol/K] \\(R_s = \\mathscr{R}/M_s\\) : gas constant specific to species \\(s\\) [J/kg/K] \\(c\\dsub{air} = \\frac{p}{\\mathscr{R}T}\\) [kmol air / m \\(^3\\) air]: molar concentration of dry air \\(\\rho\\dsub{\\specidx}\\) [kg/m \\(^3\\) ]: density of species \\(\\specidx\\) (gas, liquid or solid). The volume used to calculate the density is the volume of air in which the species is suspended. \\(i\\) , \\(j\\) [-]: indices of log-normal modes \\(I\\) [-]: total number of log-normal modes \\(D\\dsub{p}\\) [m]: particle diameter \\(N\\dsub{i}\\) [#/m \\(^{-3}\\) ]: number concentration of particles in mode \\(i\\) \\(n\\dsub{i} (D\\dsub{p})\\) [m \\(^{-4}\\) ]: size distribution of aerosol particles in mode \\(i\\) , expressed as a function of \\(D\\dsub{p}\\) (\\refeq{n_Dp}) \\(n\\dsub{i} (\\ln D\\dsub{p})\\) [m \\(^{-3}\\) ]: size distribution of aerosol particles in mode \\(i\\) , expressed as a function of \\(\\ln D\\dsub{p}\\) (\\refeq{n_lnDp}) \\(n\\dsub{norm,i} (\\ln D\\dsub{p})\\) [-]: \\(n\\dsub{i} (\\ln D\\dsub{p})\\) normalized by the mode's number concentration \\(N\\dsub{i}\\) \\(D\\dsub{gn,d,i}\\) [m]: geometric mean of dry particle diameter \\(D\\dsub{p}\\) in mode \\(i\\) \\(D\\dsub{gn,w,i}\\) [m]: geometric mean of wet particle diameter \\(D\\dsub{p}\\) in mode \\(i\\) \\(\\sigma\\dsub{g,i}\\) [m]: geometric standard deviation of \\(D\\dsub{p}\\) in mode \\(i\\) \\(V\\dsub{d,i}\\) [m \\(^3\\) particles/m \\(^3\\) dry air]: volume concentration of dry aerosol particles in mode \\(i\\) \\(V\\dsub{w,i}\\) [m \\(^3\\) particles/m \\(^3\\) dry air]: volume concentration of wet aerosol particles in mode \\(i\\) \\(V\\dsub{\\specidx,i}\\) [m \\(^3\\) species \\(\\specidx\\) /m \\(^3\\) dry air]: dry volume of species \\(\\specidx\\) in mode \\(i\\) \\(q\\dsub{n,i}\\) [#/kmol]: total number mixing ratio of particles in mode \\(i\\) \\(\\amass{\\specidx}\\) [kmol species \\(\\specidx\\) /kmol dry air in microphysics, kg species \\(\\specidx\\) /kg dry air in dry/wet deposition]: mass mixing ratio for aerosol species \\(\\specidx\\) in mode \\(i\\) \\(\\rho\\dsub{d,i}\\) [kg dry aerosol particles/m \\(^3\\) dry aerosol particles]: density of dry aerosol particles in mode \\(i\\) \\(\\rho_{w,i}\\) [kg wet particles/m \\(^3\\) wet particles]: density of wet aerosol particles in mode \\(i\\) \\(\\vmass{\\specidx}\\) [kmol species \\(s\\) /kmol dry air in microphysics, elsewhere kg species \\(s\\) /kg dry air]: mass mixing ratio of gas vapor species \\(\\Delta t_{phys}\\) [s]: time step size for aerosol physics","title":"Glossary"},{"location":"glossary/#glossary","text":"This section contains definitions of important terms and mathematical quantities used in Haero.","title":"Glossary"},{"location":"glossary/#terminology","text":"Here are terms you may encounter when reading about Haero's aerosol processes. Cloud Condensation Nuclei (CCN) : Precursors : Secondary Aerosols :","title":"Terminology"},{"location":"glossary/#mathematical-notation","text":"The following symbols are used in equations within Haero's aerosol processes. Relevant units are given in square brackets next to their symbols. [-] indicates that a quantity is unitless. \\(T\\) : air temperature [K] \\(p\\) : air pressure [Pa] \\(M_s\\) : molecular weight of chemical species \\(s\\) [kg/mol]. Note that \\(M_{air}\\) = 28.966 \\(~kg~\\) \\cdot \\(~kmol\\) ^{-1}$ in E3SM. \\(\\mathscr{R}\\) : universal gas constant [J/mol/K] \\(R_s = \\mathscr{R}/M_s\\) : gas constant specific to species \\(s\\) [J/kg/K] \\(c\\dsub{air} = \\frac{p}{\\mathscr{R}T}\\) [kmol air / m \\(^3\\) air]: molar concentration of dry air \\(\\rho\\dsub{\\specidx}\\) [kg/m \\(^3\\) ]: density of species \\(\\specidx\\) (gas, liquid or solid). The volume used to calculate the density is the volume of air in which the species is suspended. \\(i\\) , \\(j\\) [-]: indices of log-normal modes \\(I\\) [-]: total number of log-normal modes \\(D\\dsub{p}\\) [m]: particle diameter \\(N\\dsub{i}\\) [#/m \\(^{-3}\\) ]: number concentration of particles in mode \\(i\\) \\(n\\dsub{i} (D\\dsub{p})\\) [m \\(^{-4}\\) ]: size distribution of aerosol particles in mode \\(i\\) , expressed as a function of \\(D\\dsub{p}\\) (\\refeq{n_Dp}) \\(n\\dsub{i} (\\ln D\\dsub{p})\\) [m \\(^{-3}\\) ]: size distribution of aerosol particles in mode \\(i\\) , expressed as a function of \\(\\ln D\\dsub{p}\\) (\\refeq{n_lnDp}) \\(n\\dsub{norm,i} (\\ln D\\dsub{p})\\) [-]: \\(n\\dsub{i} (\\ln D\\dsub{p})\\) normalized by the mode's number concentration \\(N\\dsub{i}\\) \\(D\\dsub{gn,d,i}\\) [m]: geometric mean of dry particle diameter \\(D\\dsub{p}\\) in mode \\(i\\) \\(D\\dsub{gn,w,i}\\) [m]: geometric mean of wet particle diameter \\(D\\dsub{p}\\) in mode \\(i\\) \\(\\sigma\\dsub{g,i}\\) [m]: geometric standard deviation of \\(D\\dsub{p}\\) in mode \\(i\\) \\(V\\dsub{d,i}\\) [m \\(^3\\) particles/m \\(^3\\) dry air]: volume concentration of dry aerosol particles in mode \\(i\\) \\(V\\dsub{w,i}\\) [m \\(^3\\) particles/m \\(^3\\) dry air]: volume concentration of wet aerosol particles in mode \\(i\\) \\(V\\dsub{\\specidx,i}\\) [m \\(^3\\) species \\(\\specidx\\) /m \\(^3\\) dry air]: dry volume of species \\(\\specidx\\) in mode \\(i\\) \\(q\\dsub{n,i}\\) [#/kmol]: total number mixing ratio of particles in mode \\(i\\) \\(\\amass{\\specidx}\\) [kmol species \\(\\specidx\\) /kmol dry air in microphysics, kg species \\(\\specidx\\) /kg dry air in dry/wet deposition]: mass mixing ratio for aerosol species \\(\\specidx\\) in mode \\(i\\) \\(\\rho\\dsub{d,i}\\) [kg dry aerosol particles/m \\(^3\\) dry aerosol particles]: density of dry aerosol particles in mode \\(i\\) \\(\\rho_{w,i}\\) [kg wet particles/m \\(^3\\) wet particles]: density of wet aerosol particles in mode \\(i\\) \\(\\vmass{\\specidx}\\) [kmol species \\(s\\) /kmol dry air in microphysics, elsewhere kg species \\(s\\) /kg dry air]: mass mixing ratio of gas vapor species \\(\\Delta t_{phys}\\) [s]: time step size for aerosol physics","title":"Mathematical Notation"},{"location":"installation/","text":"Installation Haero builds and runs on the following platforms: Mac and Linux laptops and workstations NERSC Cori Compy and Constance at PNNL Required Software To build Haero, you need: CMake v3.12+ GNU Make reliable C and C++ compilers a good Fortran compiler, such as GNU gfortran or Intel's ifort compiler a working MPI installation (like OpenMPI or Mpich ). You can obtain all of these (except perhaps your favorite Fortran compiler) freely on the Linux and Mac platforms. On Linux, just use your favorite package manager. On a Mac, you can get the Clang C/C++ compiler by installing XCode, and then use a package manager like Homebrew or MacPorts to get the rest. For example, to download the relevant software on your Mac using Homebrew, type brew install cmake gfortran openmpi Clone the Repository First, go get the source code at GitHub: SSH HTTPS git clone git@github.com:eagles-project/haero.git git clone https://github.com/eagles-project/haero.git This places a haero folder into your current path. Configure Haero Haero uses CMake, and accepts a number of options that specify how it should be built. In order to simplify the build process, we've provided a simple setup script that generates a shell script you can run to invoke CMake with the appropriate options set. To configure Haero: Create a build directory by running the setup script from the top-level source directory: ./setup build Change to your build directory and edit the config.sh file to select configuration options. Then run ./config.sh to configure the model. If you prefer, you can fish the options out of the setup script (or your generated config.sh file) and feed them directly to CMake. Build, Test, and Install Haero After you've configured Haero, you can build it: From the build directory, type make -j to build the library. (If you've configured your build for a GPU, place a number after the -j flag, as in make -j 8 ). To run tests for the library (and the driver, if configured), type make test . To install the model to the location indicated by PREFIX in your config.sh script (or CMAKE_INSTALL_PREFIX , if you specified it manually), type make install . By default, products are installed in include , lib , bin , and share \u0455ubdirectories within your build directory. Making code changes and rebuilding Notice that you must build Haero in a build tree , separate from its source trees. This is standard practice in CMake-based build systems, and it allows you to build several different configurations without leaving generated and compiled files all over your source directory. However, you might have to change the way you work in order to be productive in this kind of environment. When you make a code change, make sure you build from the build directory that you created in step 1 above: cd /path/to/haero/build make -j You can also run tests from this build directory with make test . This is very different from how some people like to work. One method of making this easier is to use an editor in a dedicated window, and have another window open with a terminal, sitting in your build directory. If you're using a fancy modern editor, it might have a CMake-based workflow that handles all of this for you. The build directory has a structure that mirrors the source directory, and you can type make in any one of its subdirectories to do partial builds. In practice, though, it's safest to always build from the top of the build tree. Generating Documentation Haero's documentation is built using Material for Mkdocs , which is a static website generator with lots of features. Currently, though, the Haero repository is private, so we don't publish the documentation to a web site. Instead, if you've installed Mkdocs , you can run a local server to view the documentation. FAQ When I run config.sh, I see an error complaining about a bad fd number! You probably typed sh config.sh to run the configuration script. It's actually a bash script. Just type ./config.sh . How do I \"reconfigure my build\"? If you want to change a compile-time parameter in your model, you must reconfigure and rebuild it. To do this, edit your config.sh and change the parameter as needed. Then rerun it with ./config.sh . After the script finishes, executing you can type make -j to rebuild the model. A pull request has the reconfig required label. What does this mean? A pull request with the reconfig required label has made a change to the structure of the config.sh script, so you must rerun setup <build_dir> to regenerate your config.sh script. Once you've regenerated this script, you can reconfigure and build as usual.","title":"Installation"},{"location":"installation/#installation","text":"Haero builds and runs on the following platforms: Mac and Linux laptops and workstations NERSC Cori Compy and Constance at PNNL","title":"Installation"},{"location":"installation/#required-software","text":"To build Haero, you need: CMake v3.12+ GNU Make reliable C and C++ compilers a good Fortran compiler, such as GNU gfortran or Intel's ifort compiler a working MPI installation (like OpenMPI or Mpich ). You can obtain all of these (except perhaps your favorite Fortran compiler) freely on the Linux and Mac platforms. On Linux, just use your favorite package manager. On a Mac, you can get the Clang C/C++ compiler by installing XCode, and then use a package manager like Homebrew or MacPorts to get the rest. For example, to download the relevant software on your Mac using Homebrew, type brew install cmake gfortran openmpi","title":"Required Software"},{"location":"installation/#clone-the-repository","text":"First, go get the source code at GitHub: SSH HTTPS git clone git@github.com:eagles-project/haero.git git clone https://github.com/eagles-project/haero.git This places a haero folder into your current path.","title":"Clone the Repository"},{"location":"installation/#configure-haero","text":"Haero uses CMake, and accepts a number of options that specify how it should be built. In order to simplify the build process, we've provided a simple setup script that generates a shell script you can run to invoke CMake with the appropriate options set. To configure Haero: Create a build directory by running the setup script from the top-level source directory: ./setup build Change to your build directory and edit the config.sh file to select configuration options. Then run ./config.sh to configure the model. If you prefer, you can fish the options out of the setup script (or your generated config.sh file) and feed them directly to CMake.","title":"Configure Haero"},{"location":"installation/#build-test-and-install-haero","text":"After you've configured Haero, you can build it: From the build directory, type make -j to build the library. (If you've configured your build for a GPU, place a number after the -j flag, as in make -j 8 ). To run tests for the library (and the driver, if configured), type make test . To install the model to the location indicated by PREFIX in your config.sh script (or CMAKE_INSTALL_PREFIX , if you specified it manually), type make install . By default, products are installed in include , lib , bin , and share \u0455ubdirectories within your build directory.","title":"Build, Test, and Install Haero"},{"location":"installation/#making-code-changes-and-rebuilding","text":"Notice that you must build Haero in a build tree , separate from its source trees. This is standard practice in CMake-based build systems, and it allows you to build several different configurations without leaving generated and compiled files all over your source directory. However, you might have to change the way you work in order to be productive in this kind of environment. When you make a code change, make sure you build from the build directory that you created in step 1 above: cd /path/to/haero/build make -j You can also run tests from this build directory with make test . This is very different from how some people like to work. One method of making this easier is to use an editor in a dedicated window, and have another window open with a terminal, sitting in your build directory. If you're using a fancy modern editor, it might have a CMake-based workflow that handles all of this for you. The build directory has a structure that mirrors the source directory, and you can type make in any one of its subdirectories to do partial builds. In practice, though, it's safest to always build from the top of the build tree.","title":"Making code changes and rebuilding"},{"location":"installation/#generating-documentation","text":"Haero's documentation is built using Material for Mkdocs , which is a static website generator with lots of features. Currently, though, the Haero repository is private, so we don't publish the documentation to a web site. Instead, if you've installed Mkdocs , you can run a local server to view the documentation.","title":"Generating Documentation"},{"location":"installation/#faq","text":"When I run config.sh, I see an error complaining about a bad fd number! You probably typed sh config.sh to run the configuration script. It's actually a bash script. Just type ./config.sh . How do I \"reconfigure my build\"? If you want to change a compile-time parameter in your model, you must reconfigure and rebuild it. To do this, edit your config.sh and change the parameter as needed. Then rerun it with ./config.sh . After the script finishes, executing you can type make -j to rebuild the model. A pull request has the reconfig required label. What does this mean? A pull request with the reconfig required label has made a change to the structure of the config.sh script, so you must rerun setup <build_dir> to regenerate your config.sh script. Once you've regenerated this script, you can reconfigure and build as usual.","title":"FAQ"},{"location":"library/","text":"The Haero Library Overview Haero is designed to provide a modal aerosol capability to an atmospheric model written in C++ and/or Fortran. It makes no attempt to describe or evolve any atmospheric phenomena outside of aerosols. Instead, Haero evolves the state of aerosols within a modal aerosol model as part of a broader atmospheric host model : a mathematically consistent description of the atmosphere. To use Haero in your own host model, you write code to interact to construct a modal aerosol system and invoke aerosol processes on that system. Haero gives you all the flexibility and control you need to define how the aerosol processes couple with and interoperate with the other processes in the host model. In this sense, Haero is a set of building blocks you can use to construct the most appropriate modal aerosol representation for your host model. Haero provides an interface for running aerosol processes to evolve a set of state data within a single atmospheric column. You can evolve several columns in parallel, as long as state data is provided for each column. All quantities in Haero are specified using the International System of Units (SI) unless otherwise specified. In both code comments and documentation, we place square brackets indicating units after the description of a quantity (e.g. simulation time [s]). Aerosol Systems Haero's representation of aerosols relies on a set of simple data structures that define the assumptions underlying a specific modal aerosol system. These elements are: Modes : statistical representations of aerosol particle populations organized by particle size Species : aerosol and gas molecules of interest. Each aerosol species belongs to a single aerosol mode and is tracked by mass and number. Gas species are assumed to be small and don't belong to modes. An Aerosol Configuration : the collection of modes and species of interest within a specific modal aerosol system to be simulated These entities define the aerosol system of interest in Haero, and provide any related metadata needed to make decisions about how an aerosol processes does its work. Aerosol State Data Haero deals with two distinct types of state variables: Prognostic variables : variables that are evolved in time according to a system of differential equations Diagnostic variables : variables that are algebraically related to other variables, whether those variables are prognostic or diagnostic Prognostic variables are quantities that possess an initial state and are evolved forward in time by their tendencies (time derivatives). It is not possible to construct the value of a prognostic variable at time \\(t\\) without an initial condition at some time \\(t_0\\) and a tendency defined over the period \\(\\left[t_0, t\\right]\\) . The concept of a \"diagnostic\" variable is more general than its name suggests. The word diagnostic suggests that the variable is used only as an indicator by a human attempting to \"diagnose\" some atmospheric condition. In fact, a diagnostic variable can be any variable whose state can be constructed at any instant in time, using only the relevant prognostic variables. In this sense, a diagnostic variable serves as a \"shared\" variable that can be computed at the appropriate time, and used by one or more aerosol processes. Haero's aerosol state data lives in multi-dimensional arrays within \"smart containers\": The Prognostics container contains prognostic state variables specific to aerosols The Atmosphere container contains a thermodynamic description of the atmosphere in which an aerosol system is embedded The Diagnostics container contains a registry of diagnostic variables shared amongst various aerosol processes, and made available for output The arrays in these data structures are stored in Kokkos Views . Aerosol state data is allocated in C++, but available for use in Fortran for implementing aerosol processes or for using Haero from within a Fortran host model. Atmospheric state data is provided by the host model. Aerosol Processes The aerosol \"life cycle\" consists of a set of complicated physical processes involving many participants, with a wide range of length and time scales. These different scales demand a degree of flexibility in how we evaluate changes to the state of an aerosol system. For example, we expect to be able to resolve processes whose time scale is similar to or larger than the time scale for convection in the atmosphere, whereas processes with faster time scales must be treated in some special way that accommodates a relaxation or equilibration process. In Haero, an \"aerosol process\" accepts a set of completely specified input (prognostic and diagnostic variables, an atmospheric state, etc) and calculates a set of tendencies for prognostic aerosol and gas variables. An aerosol process consists of a set of parameterizations that encode simplifying assumptions about a specific stage of the aerosol life cycle into an algorithm that computes the relevant quantities of interest. The processes provided by Haero, and their various parameterizations, are described in processes . These processes are the true assets of the Haero library. They can be implemented in C++, in Fortran, or in both. This allows aerosol researchers to make their latest parameterizations available in the Haero library, while providing software engineers with a \"future-proof\" environment for optimizing these and other parameterizations for DOE's Leadership Class Facilities. That's an orbit-level view of the Haero library. Now let's take a closer look at each of these aspects. Aerosol Systems in Haero To model a specific aerosol system in Haero, we must answer some questions: How are aerosol particle sizes represented? What species are present in the system, and how are their sizes reflected in the particle size distribution? How is the state of an aerosol system represented mathematically? How many vertical levels are needed to resolve the profile of aerosols in the system? What are the relevent physical processes that describe the evolution of the aerosol system? Each of these decisions greatly affects the nature of the system--systems with different answers to these questions can have very different behavior. Haero attempts to answer these questions with a few basic data structures. Particle Sizes: the Mode Type We've seen how the dynamics of aerosols can be represented mathematically by evolution equations for moments of modal distribution functions. Modes simplify the description of aerosol particles in terms of their size: instead of representing a population of particles with a distribution function \\(n(V_p, \\vec{x}, t)\\) that varies continuously with the size of the particle, we introduced \\(M\\) discrete modes and declared that these modes partition the population of aerosol particles in the sense of the modal assumption as given by \\refeq{modal_n}. The essential information in a mode is the range of particle sizes it encompasses, \\([D_{\\min}, D_{\\max}]\\) , and its geometric standard deviation, \\(\\sigma_g\\) . In Haero's C++ interface, we represent an aerosol mode with the Mode struct, whereas in Fortran we use the mode_t derived type: C++ Fortran struct Mode { std :: string name ; // a unique identifier for the mode Real min_diameter ; // the mode's minimum particle diameter [m] Real max_diameter ; // the mode's maximum particle diameter [m] Real mean_std_dev ; // the geometric mean standard deviation for the mode [m] }; type :: mode_t ! Mode name character ( len = :), allocatable :: name ! Minimum particle diameter [m] real ( wp ) :: min_diameter ! Maximum particle diameter [m] real ( wp ) :: max_diameter ! Geometric mean standard deviation [m] real ( wp ) :: mean_std_dev end type The log-normal PDF for each mode is defined by two quantities, the (constant) mean standard deviation contained within the Mode class, and the geometric mean. The geometric mean is a variable function of the mass mixing ratios of all species contained within the mode and the number mixing ratio of the mode itself. Since these are time-dependent variables, they are not contained in the Mode class, which is for (invariant) metadata only. We also note that, mathematically, the log-normal size distributions of each mode do not have a maximum or minimum; they are bounded by 0 and \\(\\infty\\) . The min_diameter and max_diameter member variables should therefore not be interpreted in the context of the log-normal functions defined by e.g., \\eqref{eq:log_normal_pdf_log}. Instead they represent the boundaries beyond which particles are better described by a different mode. These minimum and maximum sizes are used to trigger redistribution of particle mass and number mixing ratios between modes. In principle, a Haero calculation can support any number of modes, but care must be taken to ensure that the modal assumptions remain valid, and that the parametrizations selected can accommodate the given modes. Aerosol Species: the Species Type A particle species is a specifically-identified molecular assembly with a number of relevant physical properties. The fundamental description of a species includes a descriptive name (e.g. sulfate ) a symbolic name (e.g. SO4 , for sulfate) information about the chemical properties of the species Each aerosol mode consists of one or more particle species. Additionally, gas particles also come in different species. Aerosol particles and gas particles have physical properties that are described respectively by the AerosolSpecies and GasSpecies types in C++, and the aerosol_species_t and gas_species_t derived types in Fortran. In Haero, we represent this information in the following way: C++ Fortran struct AerosolSpecies { std :: string name ; // full species name std :: string symbol ; // abbreviated symbolic name Real molecular weight ; // molecular weight [g/mol] Real crystalization_point ; // crystalization point [?] Real deliquescence_point ; // deliquenscence point [?] }; struct GasSpecies { std :: string name ; // full species name std :: string symbol ; // abbreviated symbolic name Real molecular weight ; // molecular weight [g/mol] }; type :: aerosol_species_t ! Species name character ( len = :), allocatable :: name ! Species symbol (abbreviation) character ( len = :), allocatable :: symbol ! Molecular weight [g/mol] real ( wp ) :: molecular_wt ! Crystalization point [?] real ( wp ) :: crystal_pt ! Deliquenscence point [?] real ( wp ) :: deliques_pt end type type :: gas_species_t ! Species name character ( len = :), allocatable :: name ! Species symbol (abbreviation) character ( len = :), allocatable :: symbol ! Molecular weight [g/mol] real ( wp ) :: molecular_wt end type Species and Their Sizes: the Modal Aerosol Configuration Type We have data types that express particle sizes and particle species. Now we need something that relates these two pieces of information. In other words, we need a way to express how particles of a specific aerosol species are allowed to grow and shrink, and how that activity is reflected in our representation of particle sizes. In the past, aerosol models have often elected to fix the modes and aerosol/gas species that they treat, in order to simplify code development. Haero instead allows a researcher to select these modes and species at runtime, allowing a far greater family of aerosol models to be represented. C++ Fortran class ModalAerosolConfig final { public : // Constructor -- creates a new modal aerosol configuration given all relevant // data. ModalAerosolConfig ( const std :: vector < Mode >& aerosol_modes , const std :: vector < AerosolSpecies >& aerosol_species , const std :: map < std :: string , std :: vector < std :: string > >& mode_species , const std :: vector < AerosolSpecies >& gas_species ); // The list of aerosol modes. std :: vector < Mode > aerosol_modes ; // The list of aerosol species. std :: vector < Species > aerosol_species ; // The list of gas species. std :: vector < Species > gas_species ; // The total number of distinct aerosol species populations in the // system, counting appearances of one species in different modes separately. int num_aerosol_populations ; // Returns the list of aerosol species associated with the system with the // given mode index. std :: vector < Species > aerosol_species_for_mode ( int mode_index ) const ; }; type :: modal_aerosol_config_t ! The aerosol modes in the model, in indexed order. type ( mode_t ), dimension (:), allocatable :: aerosol_modes ! The number of modes in the model. Equal to size(aerosol_modes). integer :: num_aerosol_modes ! The number of actual species that exist within each mode. integer , dimension (:), allocatable :: num_mode_species ! population index offsets for modes. integer , dimension (:), allocatable :: population_offsets ! The total number of distinct aerosol populations. integer :: num_aerosol_populations ! The aerosol species within each mode. Indexed as (mode, species). type ( aerosol_species_t ), dimension (:,:), allocatable :: aerosol_species ! The gas species in the model. type ( gas_species_t ), dimension (:), allocatable :: gas_species ! The number of gases in the model. Equal to size(gas_species). integer :: num_gases contains ! Returns the maximum number of aerosol species found in any aerosol mode. procedure :: max_species_per_mode => m_max_species_per_mode ! Given the index of an aerosol population, retrieve its mode and ! (modal) species indices. procedure :: get_mode_and_species => m_get_mode_and_species ! Given the name of a mode, retrieve its index. procedure :: aerosol_mode_index => m_aerosol_mode_index ! Given a mode index and the symbolic name of an aerosol species, retrieve ! its index within that mode procedure :: aerosol_species_index => m_aerosol_species_index ! Given mode and aerosol species indices, retrieve a population index ! that can be used to access aerosol data. procedure :: population_index => m_population_index ! Given the symbolic name of a gas, retrieve its index. procedure :: gas_index => m_gas_index end type Once you have a modal aerosol configuration, you can answer the first two questions at the beginning of this section. Next, we look at how the state of an aerosol system is represented mathematically. Aerosol and Atmospheric State: Container Types Once you've described the constituents of your aerosol system with a modal aerosol configuration, you can create state variables for that system. The state of an aerosol system is defined by the following prognostic variables within the Prognostics data structure: aerosol modal mass mix fraction \\(q_{m,s}\\) : the ratio of aerosol mass to dry air mass for aerosol species \\(s\\) occupying mode \\(m\\) \\(q_{m,s}\\) [kg aerosol species \\(s\\) /kg dry air] gas mass mix fraction \\(q_g\\) : the ratio of the mass of gas species \\(g\\) to dry air mass [kg gas species \\(g\\) /kg dry air] modal number concentrations \\(n_m\\) : the total number of particles per unit mass of dry air in the mode \\(m\\) [# /kg dry air] The state of the atmosphere (expressed in averaged thermodynamic quantities like pressure and temperature) greatly affects the behavior of aerosols, so this atmosphere state information is made available in the Atmosphere data structure. Finally, the system can use a set of diagnostic variables, stored in the Diagnostics data structure, that depend on a set of aerosol processes (which are discussed in a later section). The Prognostics , Atmosphere , and Diagnostics containers store state data in multidimensional arrays allocated in C++ but made available to both C++ and Fortran. The data for each array is stored within a Kokkos View . Digression: Kokkos Views as Multidimensional Arrays The C++ programming language has lots of features, but remarkably it includes no mechanism for allocating multidimensional arrays at runtime. The Kokkos C++ library fills this gap by providing a data structure called a View . A View is essentially an interface that allows a C++ programmer to treat a chunk of memory like a multidimensional array. A View has a rank and a set of dimensions, just like an allocatable Fortran array. You access a View in the same way that you'd access a Fortran array, except that A Kokkos View uses row-major indexing instead of Fortran's column-major indexing A Kokkos View uses 0-based indexing instead of Fortran's 1-based indexing So for a rank-3 view f that you access in C++ as f(i,j,k) , you would access the corresponding array element in Fortran as f(k-1,j-1,i-1) . Clear as mud? Welcome to mixed language development! Packs and Vectorization} Haero uses Views that consist of Pack objects instead of floating point numbers. A Pack (or just \"pack\" is a contiguous array of numbers that allows a modern CPU or GPU to vectorize calculations using special instructions. When executing a vector instruction, a processor performs arithmetic on more than one number at a time within a mathematical expression. In many cases, vectorizing expressions can produce significantly faster code. The cost of this optimization is that a pack represents several numbers, not one. This can make it tricky to reason about the physical quantities stored in a pack. Haero uses packs with a size (number of contiguously stored numbers) set at compile time by the CMake variable HAERO_PACK_SIZE . To simplify the process of reasoning about packs, Haero uses these objects one way only: in Haero a pack stores data for HAERO_PACK_SIZE vertical levels in a column. Thus, a pack contains data for exactly one variable (with the same units and physical interpretation) whose values span one or more vertical levels. This is the easiest way for Haero to support vectorization. It does mean, however, that the number of vertical levels in a column differs in general from the number of packs spanning a vertical level. For example, a column of data with 72 vertical levels running in a Haero build with a HAERO_PACK_SIZE of 2 contains $36 = 72 / 2 $ packs in its vertical extent. Haero-Specific Views Because Haero is concerned with arrays having very specific dimensions, we define some named types that correspond to views/arrays that span specific spaces: View Name Rank Description C++ Fortran ColumnView 1 Maps a vertical level index \\(k\\) to a pack v(k) v(k) SpeciesColumnView 2 Maps a population index \\(p\\) and a vertical level index \\(k\\) to a pack v(p,k) v(k,p) ModeColumnView 2 Maps a mode index \\(m\\) and a vertical level index \\(k\\) to a pack v(m,k) v(k,m) The Prognostics , Atmosphere , and Diagnostics containers described below make use of these named types. Prognostics Type The Prognostics type provides access to prognostic variables that describe aerosols in a modal description. Here's the essential information for the C++ and Fortran interfaces (abbreviated for brevity---see the full interfaces in haero/prognostics.hpp and haero/haero.F90 ): C++ Fortran class Prognostics final { public : // Returns the number of aerosol modes in the system. int num_aerosol_modes () const ; // Returns the number of aerosol species in the mode with the given index. int num_aerosol_species ( int mode_index ) const ; // Returns the number of gas species in the system. int num_gas_species () const ; // Returns the number of vertical levels in the system. int num_levels () const ; // Returns the view storing interstitial aerosol species mass mixing fraction // data. const SpeciesColumnView & interstitial_aerosols () const ; // Returns the view storing cloud-borne aerosol species mass mixing fraction // data. const SpeciesColumnView & cloudborne_aerosols () const ; // Returns the view storing mass mixing fraction data for gas species. const SpeciesColumnView & gases () const ; // Returns the view storing modal number concentrations. const ModeColumnView & modal_num_concs () const ; // Scales the given set of tendencies and adds it into this state, summing // the values of the prognostic variables in place. void scale_and_add ( Real scale_factor , const Tendencies & tendencies ); }; type :: prognostics_t contains ! Access to interstitial aerosol mix fractions array (no dummy arguments) procedure :: interstitial_aerosols => p_int_aero_mix_frac ! Access to cloudborne aerosol mix fractions array (no dummy arguments) procedure :: cloudborne_aerosols => p_cld_aero_mix_frac ! Access to gas mix fractions array (no dummy arguments) procedure :: gases => p_gas_mix_frac ! Access to modal number concentrations array (no dummy arguments) procedure :: modes => p_modal_num_concs end type Typically, you never modify a Prognostics variable directly. Instead, you compute a set of tendencies in a Tendencies variable and accumulate them into your Prognostics variable by calling scale_and_add . Atmosphere Type The Atmosphere type stores a fixed set of state variables that describe the atmosphere, such as temperature [K] pressure [Pa] relative humidity [-] heights at level interfaces [m] Each of these variables are stored in ColumnView objects whose memory is managed by the host model. Here's how the interfaces look: C++ Fortran Diagnostics Type The Diagnostics type stores a dynamically-determined set of diagnostic variables that correspond to the specific parameterizations available to a specific aerosol system. The variables are identified by unique tokens that can be retrieved by name. C++ Fortran class Diagnostics final { public : // Returns the number of aerosol modes in the system. int num_aerosol_modes () const ; // Returns the number of aerosol species in the mode with the given index. int num_aerosol_species ( int mode_index ) const ; // Returns the number of gas species in the system. int num_gas_species () const ; // Returns the number of vertical levels in the system. int num_levels () const ; // Returns a unique token that identifies the given (non-modal) variable // within this object. Returns VAR_NOT_FOUND if this variable does not exist. Token find_var ( const std :: string & name ) const ; // Returns the view storing the diagnostic variable with a name corresponding // to the given token. If such a variable does not exist, this throws an // exception. ColumnView & var ( const Token token ); // Returns a unique token that identifies the given modal aerosol variable // within this object. Returns VAR_NOT_FOUND if this variable does not exist. Token find_aerosol_var ( const std :: string & name ) const ; // Returns the view storing the modal aerosol diagnostic variable with a name // corresponding to the given token. If such a variable does not exist, this // throws an exception. SpeciesColumnView & aerosol_var ( const Token token ); // Returns a unique token that identifies the given gas variable within this // object. Returns VAR_NOT_FOUND if this variable does not exist. Token find_gas_var ( const std :: string & name ) const ; // Returns the view storing the gas diagnostic variable with a name // corresponding to the given token. If such a variable does not exist, this // throws an exception. SpeciesColumnView & gas_var ( const Token token ); // Returns a unique token that identifies the given modal variable within // this object. Returns VAR_NOT_FOUND if this variable does not exist. Token find_modal_var ( const std :: string & name ) const ; // Returns the view storing the mode-specific diagnostic variable with a name // corresponding to the given token. If such a variable does not exist, this // throws an exception. ModeColumnView & modal_var ( const Token token ); }; type :: diagnostics_t contains ! Returns a token that can be used to retrieve a variable with the given ! name from a diagnostics object, or var_not_found (-1) if no such variable ! exists. procedure :: find_var ( name ) -> token ! Provides access to the given (non-modal) variable in the given ! diagnostics object, given its token procedure :: var ( token ) -> array pointer ! Returns a token that can be used to retrieve an aerosol variable with the ! given name and mode from a diagnostics object, or var_not_found (-1) if no such ! variable exists. procedure :: find_aerosol_var ( name ) -> token ! Provides access to the given (non-modal) variable in the given ! diagnostics object, given its token. procedure :: aerosol_var ( token ) -> array pointer ! Returns a token that can be used to retrieve a gas variable with the ! given name from a diagnostics object, or var_not_found (-1) if no such ! variable exists. procedure :: find_gas_var ( name ) -> token ! Provides access to the given gas variable in the given diagnostics object, ! given its token. procedure :: gas_var ( token ) -> array pointer ! Returns a token that can be used to retrieve a modal variable with the ! given name from a diagnostics object, or var_not_found (-1) if no such ! variable exists. procedure :: has_modal_var ( name ) -> token ! Provides access to the given modal variable in the given ! diagnostics object, given its token. procedure :: modal_var ( token ) -> array pointer end type At this point, you might wonder how a Diagnostics variable knows which variables it needs. In fact, the Diagnostics type provides functions for creating variables that it needs when it needs them. For examples of how the Prognostics , Atmosphere , and Diagnostics types are used in practice, take a look at one of the existing aerosol process implementations. Aerosol Processes in Haero The aerosol life cycle consists of several important and distinct physical processes. Haero offers a data structures that makes it very easy to implement such a process. Because the structure of a given process doesn't depend on the details of its implementation, we can define an abstract interface to simplify its implementation. Instead of designing a new process from the ground up every time you want to add new functionality to Haero, you can simply implement a small number of functions (or subroutines) that define the behavior of a process, and let the Haero library handle the details of how these processes are created and used (and where they run). For detailed descriptions of the specific processes provided by Haero, take a look at the Aerosol Processes section. You can find examples of source code for Haero's processes in the haero/processes subdirectory. The Aerosol Process Interface An aerosol process has three behaviors which must be defined by any implementation. Each of these behaviors is implemented in a C++ function or a Fortran subroutine. initialization : the process must be able to allocate any resources it needs to do its work. These resources include temporary work arrays, look-up tables, and quantities that need to be precomputed. State data is not managed by processes, so it's not included in process initialization. If nothing needs to be done for initialization, its function or subroutine body can be empty. running : the process must know how to \"run\". In other words, it must define a procedure for computing tendencies for a relevant set of prognostic variables given their current values at a specific simulation time, along with the current values of any diagnostic variables. The function or subroutine that implements this behavior does not apply these tendencies to any prognostic variables---it simply computes the tendencies and returns. finalization : at the end of a simulation program, when the aerosol system is destroyed, the process must free all resources it allocated in its initialization. If no resources are allocated, the function or subroutine body implementing finalization can be empty. In addition, the process may support named parameters that can be set to specific values. Some examples of these kinds of parameters are Integer-valued parameters that select one of several supported algorithms Boolean flags for enabling or disabling features Real-valued scale factors for quantities based on tuning or assumptions String-valued parameters (just in case they're helpful) Haero provides an object-oriented approach for implementing a process in terms of this simple interface. In an object-oriented approach, an abstract interface is encoded in a \"base class\"--a data type that declares the necessary functions and subroutines. Then any implementation of this interface is defined in a derived class : a type derived from that base class. Haero uses the object-oriented features of C++ for process development. All aerosol process implementations are derived from a C++ base class called AerosolProcess . This is true regardless of whether you implement the process using C++ or Fortran. The AerosolProcess provides the following interface (see haero/aerosol_process.hpp for more details): AerosolProcess class AerosolProcess { public : // Constructor, called by all AerosolProcess subclasses. explicit AerosolProcess ( const std :: string & name ) : name_ ( name ) {} // Destructor. virtual ~ AerosolProcess () {} // Initializes the process with the aerosol configuration. void init ( const ModalAerosolConfig & config ); // Runs the process at the given time with the given aerosol data and the // given Kokkos thread team. void run ( const TeamType & team , Real t , Real dt , const Prognostics & prognostics , const Atmosphere & atmosphere , const Diagnostics & diagnostics , Tendencies & tendencies ) const ; // Set named integer, boolean, and real-valued parameters. void set_param ( const std :: string & name , int value ); void set_param ( const std :: string & name , bool value ); void set_param ( const std :: string & name , Real value ); // On host: copies this aerosol process to the device, returning a // pointer to the copy. AerosolProcess * copy_to_device () const ; // On host: call this static method to delete a copy of the process // that has been created on a device. static void delete_on_device ( AerosolProcess * device_process ); protected : // Override this method if your aerosol process needs to be initialized // with information about the system. The default implementation does nothing. virtual void init_ ( const ModalAerosolConfig & config ) {} // Override this method to implement the aerosol process using the specific // parameterization for the subclass. virtual void run_ ( Real t , Real dt , const Prognostics & prognostics , const Atmosphere & atmosphere , const Diagnostics & diagnostics , Tendencies & tendencies ) const = 0 ; // Override these methods to set a parameter to a given value based on its // name. virtual void set_param_ ( const std :: string & name , int value ) {} virtual void set_param_ ( const std :: string & name , bool value ) {} virtual void set_param_ ( const std :: string & name , Real value ) {} }; In addition to the \"constructor\" function used to create an instance of a AerosolProcess and the interface functions for initializing, running, and setting parameters, the interface declares protected methods with underscores after their names. These are the methods you must override in order to define the behaviors of the aerosol process. Make sure you document any supported parameters (recognized by your set_param methods). The constructor accepts a single argument: a string containing the name of the aerosol process. This can be helpful for debugging. Digression: running aerosol processes on a GPU Haero is designed to allow aerosol physics to be computed on CPUs or GPUs, with different levels of parallelism. Running code on a GPU is tricky, because the data it uses must be copied to memory allocated on the GPU itself. In fact, a process object itself must be allocated on the GPU in order for the code to run there. The process of allocating this memory on the GPU is esoteric and confusing. Haero solves this problem by inserting an intermediary class between your derived class and the AerosolProcess class. This intermediary class is named DeviceAerosolProcess . It uses C++'s curiously recurring template pattern to add all the necessary logic for your class to run on a GPU. The way it works is this: An object for your process class is allocated and initialized (via init ) on the CPU by an atmospheric host model. The host model calls the copy_to_device method to obtain a copy of the object that lives on the GPU. This method uses a copy constructor defined by your process class to copy itself from the CPU to the GPU. The host model invokes your GPU-resident object's run method within a Kokkos parallel dispatch as needed, passing it a Kokkos thread team that determines the number of threads available witin the method. When the calculation is finished, the host model calls the delete_on_device static method, passing it the GPU-resident object to deallocate it from the GPU. The most important thing to remember here is that init is called on the CPU, whether or not you intend to run your process on the GPU. You must use the init method to record any information from the ModalAerosolConfig object that defines your simulation, because ModalAerosolConfig variables cannot reside on the GPU. Parameters are also set (using set_param ) on the CPU, not the GPU. Let's explore how we might implement an aerosol process in C++ and in Fortran. Here we describe only the steps needed to implement the process itself. You must also test your process to make sure it behaves the way you think it does! The procedure for testing an aerosol process is described in the Testing section. C++ aerosol processes In C++, all you have to do in order to implement an aerosol process is to define a class with a specific name. For concreteness, let's examine a process named SimpleNucleationProcess , which lives in haero/processes/simple_nucleation_process.hpp and haero/processes/simple_nucleation_process.cpp . To allow your process to reside on a CPU or GPU, your derive your class from the DeviceAerosolProcess . This class accepts a single template parameter: your class. So in our example, you would derive SimpleNucleationProcess from DeviceAerosolProcess<SimpleNucleationProcess> . This curiously recursive trick, in which the type of the intermediary class depends on the type of its descendent, gives the Curiously Recurring Template Pattern its name. Let's not worry about how it works for now. Before we go any further, some terminology: a C++ class derived from a base class is called a subclass of that base class. So MyProcess is a subclass of DeviceAerosolProcess<SimpleNucleationProcess> , which is itself a subclass of the base class AerosolProcess . To create a C++ implemention for an aerosol process: Create a header file that declares your subclass. This header file must declare a class constructor, a copy constructor, a destructor, and the overridable init_ and run_ functions. If you want to support configurable parameters, declare whatever versions of set_param_ you need. Implement your Implement your copy constructor, your destructor, and your run_ method in the header file, declaring each with the KOKKOS_INLINE_FUNCTION macro. This allows them to be called on a GPU. Create a source file containing implementations for the remaining methods (the constructor, the init_ method, and any set_param_ methods you need). See haero/processes/simple_nucleation_process.cpp , for example. Add your source file to the set of source files in the PROCESS_SOURCES variable in haero/processes/CMakeLists.txt . Write one or more tests for your new aerosol process. The Testing section provides details about how to do this. Fortran aerosol processes A Fortran aerosol process implementation consists of a Fortran module that contains init , run , and finalize subroutines that implement the same functionality as their C++ counterparts: Fortran aerosol module module MODULE_NAME use haero , only : wp , modal_aerosol_config_t , prognostics_t , atmosphere_t , & diagnostics_t , tendencies_t ... implicit none ! Aerosol process interface subroutines public :: init , run , finalize ! Parameter setting subroutines public :: set_integer_param , set_logical_param , set_real_param ! Module variables, including settable parameters integer :: my_option logical :: my_flag real ( wp ) :: my_scale_factor ! SAVE keyword for retaining module variables save contains subroutine init ( config ) implicit none ! Arguments type ( modal_aerosol_config_t ), intent ( in ) :: config ... end subroutine subroutine run ( t , dt , prognostics , atmosphere , diagnostics , tendencies ) implicit none ! Arguments real ( wp ), value , intent ( in ) :: t real ( wp ), value , intent ( in ) :: dt type ( prognostics_t ), intent ( in ) :: prognostics type ( atmosphere_t ), intent ( in ) :: atmosphere type ( diagnostics_t ), intent ( in ) :: diagnostics type ( tendencies_t ), intent ( inout ) :: tendencies ... end subroutine subroutine finalize () implicit none ... end subroutine subroutine set_integer_param ( name , val ) implicit none ! Arguments character ( len =* ), intent ( in ) :: name integer , intent ( in ) :: val if ( trim ( name ) == \"my_option\" ) then my_option = val end if end subroutine subroutine set_logical_param ( name , val ) implicit none ! Arguments character ( len =* ), intent ( in ) :: name logical , intent ( in ) :: val if ( trim ( name ) == \"my_flag\" ) then my_flag = val end if end subroutine subroutine set_real_param ( name , val ) implicit none ! Arguments character ( len =* ), intent ( in ) :: name real ( wp ), intent ( in ) :: val if ( trim ( name ) == \"my_scale_factor\" ) then my_scale_factor = val end if end subroutine ... end module In Fortran, you must implement subroutines for set_integer_param , set_logical_param , and set_real_param , even if your process doesn't support settable parameters. To implement an aerosol process in Fortran, you create such a module in a Fortran source file and then declare it as a faerosol_process in the CMakeLists.txt file within the haero/processes subdirectory. There are instructions on how to declare your process in that file. For example, the Fortran MAM nucleation process is implemented in a Fortran module named mam_nucleation , implemented in the source file haero/processes/mam_nucleation.F90 . In haero/processes/CMakeLists.txt , it's declared as a Fortran aerosol process the following way: haero/processes/CMakeLists.txt if (HAERO_FORTRAN) ... faerosol_process(MAMNucleationFProcess NucleationProcess mam_nucleation) ... endif() The declaration takes three arguments: The name of a C++ class that will be created that exposes the Fortran implementation of the process The C++ enumerated type that identifies what kind of aerosol process is being implemented The name of the Fortran module that implements the process The build system automatically generates a C++ class for the Fortran module that allows the process to be used in a Haero simulation. The name of this C++ class is important for exposing it to the Haero library. Once you've done these things and rebuilt Haero, your new aerosol process implementation is available for use. Diagnostic Functions Aerosol processes compute tendencies for prognostic variables. But how are diagnostic variables updated? These variables are quite different in nature from their prognostic counterparts: they depend algebraically on prognostic variables and other diagnostic variables they are updated in place instead of being evolved in time by differential equations they are often shared/needed by several distinct aerosol processes, and at various points in time, depending on a given process ordering Because of these considerations, it's not clear that we can update more than a single diagnostic variable at once. To do so implies a knowledge of how the aerosol processes are invoked during a time step, and Haero does not make any such decision on behalf of a host model. This means we must provide a diagnostic variable update mechanism that is flexible but easy to understand. This mechanism, which updates a single diagnostic variable, is called a diagnostic function . Unlike aerosol processes, which have multiple behaviors associated with initialization, finalization, and the execution of the process itself, a diagnostic function only ever does one thing: it takes a set of input and uses it to update its diagnostic variable. In other words, it has no internal state of its own---it's just a function that you can call whenever you need to update a particular diagnostic variable.","title":"The Haero Library"},{"location":"library/#the-haero-library","text":"","title":"The Haero Library"},{"location":"library/#overview","text":"Haero is designed to provide a modal aerosol capability to an atmospheric model written in C++ and/or Fortran. It makes no attempt to describe or evolve any atmospheric phenomena outside of aerosols. Instead, Haero evolves the state of aerosols within a modal aerosol model as part of a broader atmospheric host model : a mathematically consistent description of the atmosphere. To use Haero in your own host model, you write code to interact to construct a modal aerosol system and invoke aerosol processes on that system. Haero gives you all the flexibility and control you need to define how the aerosol processes couple with and interoperate with the other processes in the host model. In this sense, Haero is a set of building blocks you can use to construct the most appropriate modal aerosol representation for your host model. Haero provides an interface for running aerosol processes to evolve a set of state data within a single atmospheric column. You can evolve several columns in parallel, as long as state data is provided for each column. All quantities in Haero are specified using the International System of Units (SI) unless otherwise specified. In both code comments and documentation, we place square brackets indicating units after the description of a quantity (e.g. simulation time [s]).","title":"Overview"},{"location":"library/#aerosol-systems","text":"Haero's representation of aerosols relies on a set of simple data structures that define the assumptions underlying a specific modal aerosol system. These elements are: Modes : statistical representations of aerosol particle populations organized by particle size Species : aerosol and gas molecules of interest. Each aerosol species belongs to a single aerosol mode and is tracked by mass and number. Gas species are assumed to be small and don't belong to modes. An Aerosol Configuration : the collection of modes and species of interest within a specific modal aerosol system to be simulated These entities define the aerosol system of interest in Haero, and provide any related metadata needed to make decisions about how an aerosol processes does its work.","title":"Aerosol Systems"},{"location":"library/#aerosol-state-data","text":"Haero deals with two distinct types of state variables: Prognostic variables : variables that are evolved in time according to a system of differential equations Diagnostic variables : variables that are algebraically related to other variables, whether those variables are prognostic or diagnostic Prognostic variables are quantities that possess an initial state and are evolved forward in time by their tendencies (time derivatives). It is not possible to construct the value of a prognostic variable at time \\(t\\) without an initial condition at some time \\(t_0\\) and a tendency defined over the period \\(\\left[t_0, t\\right]\\) . The concept of a \"diagnostic\" variable is more general than its name suggests. The word diagnostic suggests that the variable is used only as an indicator by a human attempting to \"diagnose\" some atmospheric condition. In fact, a diagnostic variable can be any variable whose state can be constructed at any instant in time, using only the relevant prognostic variables. In this sense, a diagnostic variable serves as a \"shared\" variable that can be computed at the appropriate time, and used by one or more aerosol processes. Haero's aerosol state data lives in multi-dimensional arrays within \"smart containers\": The Prognostics container contains prognostic state variables specific to aerosols The Atmosphere container contains a thermodynamic description of the atmosphere in which an aerosol system is embedded The Diagnostics container contains a registry of diagnostic variables shared amongst various aerosol processes, and made available for output The arrays in these data structures are stored in Kokkos Views . Aerosol state data is allocated in C++, but available for use in Fortran for implementing aerosol processes or for using Haero from within a Fortran host model. Atmospheric state data is provided by the host model.","title":"Aerosol State Data"},{"location":"library/#aerosol-processes","text":"The aerosol \"life cycle\" consists of a set of complicated physical processes involving many participants, with a wide range of length and time scales. These different scales demand a degree of flexibility in how we evaluate changes to the state of an aerosol system. For example, we expect to be able to resolve processes whose time scale is similar to or larger than the time scale for convection in the atmosphere, whereas processes with faster time scales must be treated in some special way that accommodates a relaxation or equilibration process. In Haero, an \"aerosol process\" accepts a set of completely specified input (prognostic and diagnostic variables, an atmospheric state, etc) and calculates a set of tendencies for prognostic aerosol and gas variables. An aerosol process consists of a set of parameterizations that encode simplifying assumptions about a specific stage of the aerosol life cycle into an algorithm that computes the relevant quantities of interest. The processes provided by Haero, and their various parameterizations, are described in processes . These processes are the true assets of the Haero library. They can be implemented in C++, in Fortran, or in both. This allows aerosol researchers to make their latest parameterizations available in the Haero library, while providing software engineers with a \"future-proof\" environment for optimizing these and other parameterizations for DOE's Leadership Class Facilities. That's an orbit-level view of the Haero library. Now let's take a closer look at each of these aspects.","title":"Aerosol Processes"},{"location":"library/#aerosol-systems-in-haero","text":"To model a specific aerosol system in Haero, we must answer some questions: How are aerosol particle sizes represented? What species are present in the system, and how are their sizes reflected in the particle size distribution? How is the state of an aerosol system represented mathematically? How many vertical levels are needed to resolve the profile of aerosols in the system? What are the relevent physical processes that describe the evolution of the aerosol system? Each of these decisions greatly affects the nature of the system--systems with different answers to these questions can have very different behavior. Haero attempts to answer these questions with a few basic data structures.","title":"Aerosol Systems in Haero"},{"location":"library/#particle-sizes-the-mode-type","text":"We've seen how the dynamics of aerosols can be represented mathematically by evolution equations for moments of modal distribution functions. Modes simplify the description of aerosol particles in terms of their size: instead of representing a population of particles with a distribution function \\(n(V_p, \\vec{x}, t)\\) that varies continuously with the size of the particle, we introduced \\(M\\) discrete modes and declared that these modes partition the population of aerosol particles in the sense of the modal assumption as given by \\refeq{modal_n}. The essential information in a mode is the range of particle sizes it encompasses, \\([D_{\\min}, D_{\\max}]\\) , and its geometric standard deviation, \\(\\sigma_g\\) . In Haero's C++ interface, we represent an aerosol mode with the Mode struct, whereas in Fortran we use the mode_t derived type: C++ Fortran struct Mode { std :: string name ; // a unique identifier for the mode Real min_diameter ; // the mode's minimum particle diameter [m] Real max_diameter ; // the mode's maximum particle diameter [m] Real mean_std_dev ; // the geometric mean standard deviation for the mode [m] }; type :: mode_t ! Mode name character ( len = :), allocatable :: name ! Minimum particle diameter [m] real ( wp ) :: min_diameter ! Maximum particle diameter [m] real ( wp ) :: max_diameter ! Geometric mean standard deviation [m] real ( wp ) :: mean_std_dev end type The log-normal PDF for each mode is defined by two quantities, the (constant) mean standard deviation contained within the Mode class, and the geometric mean. The geometric mean is a variable function of the mass mixing ratios of all species contained within the mode and the number mixing ratio of the mode itself. Since these are time-dependent variables, they are not contained in the Mode class, which is for (invariant) metadata only. We also note that, mathematically, the log-normal size distributions of each mode do not have a maximum or minimum; they are bounded by 0 and \\(\\infty\\) . The min_diameter and max_diameter member variables should therefore not be interpreted in the context of the log-normal functions defined by e.g., \\eqref{eq:log_normal_pdf_log}. Instead they represent the boundaries beyond which particles are better described by a different mode. These minimum and maximum sizes are used to trigger redistribution of particle mass and number mixing ratios between modes. In principle, a Haero calculation can support any number of modes, but care must be taken to ensure that the modal assumptions remain valid, and that the parametrizations selected can accommodate the given modes.","title":"Particle Sizes: the Mode Type"},{"location":"library/#aerosol-species-the-species-type","text":"A particle species is a specifically-identified molecular assembly with a number of relevant physical properties. The fundamental description of a species includes a descriptive name (e.g. sulfate ) a symbolic name (e.g. SO4 , for sulfate) information about the chemical properties of the species Each aerosol mode consists of one or more particle species. Additionally, gas particles also come in different species. Aerosol particles and gas particles have physical properties that are described respectively by the AerosolSpecies and GasSpecies types in C++, and the aerosol_species_t and gas_species_t derived types in Fortran. In Haero, we represent this information in the following way: C++ Fortran struct AerosolSpecies { std :: string name ; // full species name std :: string symbol ; // abbreviated symbolic name Real molecular weight ; // molecular weight [g/mol] Real crystalization_point ; // crystalization point [?] Real deliquescence_point ; // deliquenscence point [?] }; struct GasSpecies { std :: string name ; // full species name std :: string symbol ; // abbreviated symbolic name Real molecular weight ; // molecular weight [g/mol] }; type :: aerosol_species_t ! Species name character ( len = :), allocatable :: name ! Species symbol (abbreviation) character ( len = :), allocatable :: symbol ! Molecular weight [g/mol] real ( wp ) :: molecular_wt ! Crystalization point [?] real ( wp ) :: crystal_pt ! Deliquenscence point [?] real ( wp ) :: deliques_pt end type type :: gas_species_t ! Species name character ( len = :), allocatable :: name ! Species symbol (abbreviation) character ( len = :), allocatable :: symbol ! Molecular weight [g/mol] real ( wp ) :: molecular_wt end type","title":"Aerosol Species: the Species Type"},{"location":"library/#species-and-their-sizes-the-modal-aerosol-configuration-type","text":"We have data types that express particle sizes and particle species. Now we need something that relates these two pieces of information. In other words, we need a way to express how particles of a specific aerosol species are allowed to grow and shrink, and how that activity is reflected in our representation of particle sizes. In the past, aerosol models have often elected to fix the modes and aerosol/gas species that they treat, in order to simplify code development. Haero instead allows a researcher to select these modes and species at runtime, allowing a far greater family of aerosol models to be represented. C++ Fortran class ModalAerosolConfig final { public : // Constructor -- creates a new modal aerosol configuration given all relevant // data. ModalAerosolConfig ( const std :: vector < Mode >& aerosol_modes , const std :: vector < AerosolSpecies >& aerosol_species , const std :: map < std :: string , std :: vector < std :: string > >& mode_species , const std :: vector < AerosolSpecies >& gas_species ); // The list of aerosol modes. std :: vector < Mode > aerosol_modes ; // The list of aerosol species. std :: vector < Species > aerosol_species ; // The list of gas species. std :: vector < Species > gas_species ; // The total number of distinct aerosol species populations in the // system, counting appearances of one species in different modes separately. int num_aerosol_populations ; // Returns the list of aerosol species associated with the system with the // given mode index. std :: vector < Species > aerosol_species_for_mode ( int mode_index ) const ; }; type :: modal_aerosol_config_t ! The aerosol modes in the model, in indexed order. type ( mode_t ), dimension (:), allocatable :: aerosol_modes ! The number of modes in the model. Equal to size(aerosol_modes). integer :: num_aerosol_modes ! The number of actual species that exist within each mode. integer , dimension (:), allocatable :: num_mode_species ! population index offsets for modes. integer , dimension (:), allocatable :: population_offsets ! The total number of distinct aerosol populations. integer :: num_aerosol_populations ! The aerosol species within each mode. Indexed as (mode, species). type ( aerosol_species_t ), dimension (:,:), allocatable :: aerosol_species ! The gas species in the model. type ( gas_species_t ), dimension (:), allocatable :: gas_species ! The number of gases in the model. Equal to size(gas_species). integer :: num_gases contains ! Returns the maximum number of aerosol species found in any aerosol mode. procedure :: max_species_per_mode => m_max_species_per_mode ! Given the index of an aerosol population, retrieve its mode and ! (modal) species indices. procedure :: get_mode_and_species => m_get_mode_and_species ! Given the name of a mode, retrieve its index. procedure :: aerosol_mode_index => m_aerosol_mode_index ! Given a mode index and the symbolic name of an aerosol species, retrieve ! its index within that mode procedure :: aerosol_species_index => m_aerosol_species_index ! Given mode and aerosol species indices, retrieve a population index ! that can be used to access aerosol data. procedure :: population_index => m_population_index ! Given the symbolic name of a gas, retrieve its index. procedure :: gas_index => m_gas_index end type Once you have a modal aerosol configuration, you can answer the first two questions at the beginning of this section. Next, we look at how the state of an aerosol system is represented mathematically.","title":"Species and Their Sizes: the Modal Aerosol Configuration Type"},{"location":"library/#aerosol-and-atmospheric-state-container-types","text":"Once you've described the constituents of your aerosol system with a modal aerosol configuration, you can create state variables for that system. The state of an aerosol system is defined by the following prognostic variables within the Prognostics data structure: aerosol modal mass mix fraction \\(q_{m,s}\\) : the ratio of aerosol mass to dry air mass for aerosol species \\(s\\) occupying mode \\(m\\) \\(q_{m,s}\\) [kg aerosol species \\(s\\) /kg dry air] gas mass mix fraction \\(q_g\\) : the ratio of the mass of gas species \\(g\\) to dry air mass [kg gas species \\(g\\) /kg dry air] modal number concentrations \\(n_m\\) : the total number of particles per unit mass of dry air in the mode \\(m\\) [# /kg dry air] The state of the atmosphere (expressed in averaged thermodynamic quantities like pressure and temperature) greatly affects the behavior of aerosols, so this atmosphere state information is made available in the Atmosphere data structure. Finally, the system can use a set of diagnostic variables, stored in the Diagnostics data structure, that depend on a set of aerosol processes (which are discussed in a later section). The Prognostics , Atmosphere , and Diagnostics containers store state data in multidimensional arrays allocated in C++ but made available to both C++ and Fortran. The data for each array is stored within a Kokkos View .","title":"Aerosol and Atmospheric State: Container Types"},{"location":"library/#digression-kokkos-views-as-multidimensional-arrays","text":"The C++ programming language has lots of features, but remarkably it includes no mechanism for allocating multidimensional arrays at runtime. The Kokkos C++ library fills this gap by providing a data structure called a View . A View is essentially an interface that allows a C++ programmer to treat a chunk of memory like a multidimensional array. A View has a rank and a set of dimensions, just like an allocatable Fortran array. You access a View in the same way that you'd access a Fortran array, except that A Kokkos View uses row-major indexing instead of Fortran's column-major indexing A Kokkos View uses 0-based indexing instead of Fortran's 1-based indexing So for a rank-3 view f that you access in C++ as f(i,j,k) , you would access the corresponding array element in Fortran as f(k-1,j-1,i-1) . Clear as mud? Welcome to mixed language development!","title":"Digression: Kokkos Views as Multidimensional Arrays"},{"location":"library/#packs-and-vectorization","text":"Haero uses Views that consist of Pack objects instead of floating point numbers. A Pack (or just \"pack\" is a contiguous array of numbers that allows a modern CPU or GPU to vectorize calculations using special instructions. When executing a vector instruction, a processor performs arithmetic on more than one number at a time within a mathematical expression. In many cases, vectorizing expressions can produce significantly faster code. The cost of this optimization is that a pack represents several numbers, not one. This can make it tricky to reason about the physical quantities stored in a pack. Haero uses packs with a size (number of contiguously stored numbers) set at compile time by the CMake variable HAERO_PACK_SIZE . To simplify the process of reasoning about packs, Haero uses these objects one way only: in Haero a pack stores data for HAERO_PACK_SIZE vertical levels in a column. Thus, a pack contains data for exactly one variable (with the same units and physical interpretation) whose values span one or more vertical levels. This is the easiest way for Haero to support vectorization. It does mean, however, that the number of vertical levels in a column differs in general from the number of packs spanning a vertical level. For example, a column of data with 72 vertical levels running in a Haero build with a HAERO_PACK_SIZE of 2 contains $36 = 72 / 2 $ packs in its vertical extent.","title":"Packs and Vectorization}"},{"location":"library/#haero-specific-views","text":"Because Haero is concerned with arrays having very specific dimensions, we define some named types that correspond to views/arrays that span specific spaces: View Name Rank Description C++ Fortran ColumnView 1 Maps a vertical level index \\(k\\) to a pack v(k) v(k) SpeciesColumnView 2 Maps a population index \\(p\\) and a vertical level index \\(k\\) to a pack v(p,k) v(k,p) ModeColumnView 2 Maps a mode index \\(m\\) and a vertical level index \\(k\\) to a pack v(m,k) v(k,m) The Prognostics , Atmosphere , and Diagnostics containers described below make use of these named types.","title":"Haero-Specific Views"},{"location":"library/#prognostics-type","text":"The Prognostics type provides access to prognostic variables that describe aerosols in a modal description. Here's the essential information for the C++ and Fortran interfaces (abbreviated for brevity---see the full interfaces in haero/prognostics.hpp and haero/haero.F90 ): C++ Fortran class Prognostics final { public : // Returns the number of aerosol modes in the system. int num_aerosol_modes () const ; // Returns the number of aerosol species in the mode with the given index. int num_aerosol_species ( int mode_index ) const ; // Returns the number of gas species in the system. int num_gas_species () const ; // Returns the number of vertical levels in the system. int num_levels () const ; // Returns the view storing interstitial aerosol species mass mixing fraction // data. const SpeciesColumnView & interstitial_aerosols () const ; // Returns the view storing cloud-borne aerosol species mass mixing fraction // data. const SpeciesColumnView & cloudborne_aerosols () const ; // Returns the view storing mass mixing fraction data for gas species. const SpeciesColumnView & gases () const ; // Returns the view storing modal number concentrations. const ModeColumnView & modal_num_concs () const ; // Scales the given set of tendencies and adds it into this state, summing // the values of the prognostic variables in place. void scale_and_add ( Real scale_factor , const Tendencies & tendencies ); }; type :: prognostics_t contains ! Access to interstitial aerosol mix fractions array (no dummy arguments) procedure :: interstitial_aerosols => p_int_aero_mix_frac ! Access to cloudborne aerosol mix fractions array (no dummy arguments) procedure :: cloudborne_aerosols => p_cld_aero_mix_frac ! Access to gas mix fractions array (no dummy arguments) procedure :: gases => p_gas_mix_frac ! Access to modal number concentrations array (no dummy arguments) procedure :: modes => p_modal_num_concs end type Typically, you never modify a Prognostics variable directly. Instead, you compute a set of tendencies in a Tendencies variable and accumulate them into your Prognostics variable by calling scale_and_add .","title":"Prognostics Type"},{"location":"library/#atmosphere-type","text":"The Atmosphere type stores a fixed set of state variables that describe the atmosphere, such as temperature [K] pressure [Pa] relative humidity [-] heights at level interfaces [m] Each of these variables are stored in ColumnView objects whose memory is managed by the host model. Here's how the interfaces look: C++ Fortran","title":"Atmosphere Type"},{"location":"library/#diagnostics-type","text":"The Diagnostics type stores a dynamically-determined set of diagnostic variables that correspond to the specific parameterizations available to a specific aerosol system. The variables are identified by unique tokens that can be retrieved by name. C++ Fortran class Diagnostics final { public : // Returns the number of aerosol modes in the system. int num_aerosol_modes () const ; // Returns the number of aerosol species in the mode with the given index. int num_aerosol_species ( int mode_index ) const ; // Returns the number of gas species in the system. int num_gas_species () const ; // Returns the number of vertical levels in the system. int num_levels () const ; // Returns a unique token that identifies the given (non-modal) variable // within this object. Returns VAR_NOT_FOUND if this variable does not exist. Token find_var ( const std :: string & name ) const ; // Returns the view storing the diagnostic variable with a name corresponding // to the given token. If such a variable does not exist, this throws an // exception. ColumnView & var ( const Token token ); // Returns a unique token that identifies the given modal aerosol variable // within this object. Returns VAR_NOT_FOUND if this variable does not exist. Token find_aerosol_var ( const std :: string & name ) const ; // Returns the view storing the modal aerosol diagnostic variable with a name // corresponding to the given token. If such a variable does not exist, this // throws an exception. SpeciesColumnView & aerosol_var ( const Token token ); // Returns a unique token that identifies the given gas variable within this // object. Returns VAR_NOT_FOUND if this variable does not exist. Token find_gas_var ( const std :: string & name ) const ; // Returns the view storing the gas diagnostic variable with a name // corresponding to the given token. If such a variable does not exist, this // throws an exception. SpeciesColumnView & gas_var ( const Token token ); // Returns a unique token that identifies the given modal variable within // this object. Returns VAR_NOT_FOUND if this variable does not exist. Token find_modal_var ( const std :: string & name ) const ; // Returns the view storing the mode-specific diagnostic variable with a name // corresponding to the given token. If such a variable does not exist, this // throws an exception. ModeColumnView & modal_var ( const Token token ); }; type :: diagnostics_t contains ! Returns a token that can be used to retrieve a variable with the given ! name from a diagnostics object, or var_not_found (-1) if no such variable ! exists. procedure :: find_var ( name ) -> token ! Provides access to the given (non-modal) variable in the given ! diagnostics object, given its token procedure :: var ( token ) -> array pointer ! Returns a token that can be used to retrieve an aerosol variable with the ! given name and mode from a diagnostics object, or var_not_found (-1) if no such ! variable exists. procedure :: find_aerosol_var ( name ) -> token ! Provides access to the given (non-modal) variable in the given ! diagnostics object, given its token. procedure :: aerosol_var ( token ) -> array pointer ! Returns a token that can be used to retrieve a gas variable with the ! given name from a diagnostics object, or var_not_found (-1) if no such ! variable exists. procedure :: find_gas_var ( name ) -> token ! Provides access to the given gas variable in the given diagnostics object, ! given its token. procedure :: gas_var ( token ) -> array pointer ! Returns a token that can be used to retrieve a modal variable with the ! given name from a diagnostics object, or var_not_found (-1) if no such ! variable exists. procedure :: has_modal_var ( name ) -> token ! Provides access to the given modal variable in the given ! diagnostics object, given its token. procedure :: modal_var ( token ) -> array pointer end type At this point, you might wonder how a Diagnostics variable knows which variables it needs. In fact, the Diagnostics type provides functions for creating variables that it needs when it needs them. For examples of how the Prognostics , Atmosphere , and Diagnostics types are used in practice, take a look at one of the existing aerosol process implementations.","title":"Diagnostics Type"},{"location":"library/#aerosol-processes-in-haero","text":"The aerosol life cycle consists of several important and distinct physical processes. Haero offers a data structures that makes it very easy to implement such a process. Because the structure of a given process doesn't depend on the details of its implementation, we can define an abstract interface to simplify its implementation. Instead of designing a new process from the ground up every time you want to add new functionality to Haero, you can simply implement a small number of functions (or subroutines) that define the behavior of a process, and let the Haero library handle the details of how these processes are created and used (and where they run). For detailed descriptions of the specific processes provided by Haero, take a look at the Aerosol Processes section. You can find examples of source code for Haero's processes in the haero/processes subdirectory.","title":"Aerosol Processes in Haero"},{"location":"library/#the-aerosol-process-interface","text":"An aerosol process has three behaviors which must be defined by any implementation. Each of these behaviors is implemented in a C++ function or a Fortran subroutine. initialization : the process must be able to allocate any resources it needs to do its work. These resources include temporary work arrays, look-up tables, and quantities that need to be precomputed. State data is not managed by processes, so it's not included in process initialization. If nothing needs to be done for initialization, its function or subroutine body can be empty. running : the process must know how to \"run\". In other words, it must define a procedure for computing tendencies for a relevant set of prognostic variables given their current values at a specific simulation time, along with the current values of any diagnostic variables. The function or subroutine that implements this behavior does not apply these tendencies to any prognostic variables---it simply computes the tendencies and returns. finalization : at the end of a simulation program, when the aerosol system is destroyed, the process must free all resources it allocated in its initialization. If no resources are allocated, the function or subroutine body implementing finalization can be empty. In addition, the process may support named parameters that can be set to specific values. Some examples of these kinds of parameters are Integer-valued parameters that select one of several supported algorithms Boolean flags for enabling or disabling features Real-valued scale factors for quantities based on tuning or assumptions String-valued parameters (just in case they're helpful) Haero provides an object-oriented approach for implementing a process in terms of this simple interface. In an object-oriented approach, an abstract interface is encoded in a \"base class\"--a data type that declares the necessary functions and subroutines. Then any implementation of this interface is defined in a derived class : a type derived from that base class. Haero uses the object-oriented features of C++ for process development. All aerosol process implementations are derived from a C++ base class called AerosolProcess . This is true regardless of whether you implement the process using C++ or Fortran. The AerosolProcess provides the following interface (see haero/aerosol_process.hpp for more details): AerosolProcess class AerosolProcess { public : // Constructor, called by all AerosolProcess subclasses. explicit AerosolProcess ( const std :: string & name ) : name_ ( name ) {} // Destructor. virtual ~ AerosolProcess () {} // Initializes the process with the aerosol configuration. void init ( const ModalAerosolConfig & config ); // Runs the process at the given time with the given aerosol data and the // given Kokkos thread team. void run ( const TeamType & team , Real t , Real dt , const Prognostics & prognostics , const Atmosphere & atmosphere , const Diagnostics & diagnostics , Tendencies & tendencies ) const ; // Set named integer, boolean, and real-valued parameters. void set_param ( const std :: string & name , int value ); void set_param ( const std :: string & name , bool value ); void set_param ( const std :: string & name , Real value ); // On host: copies this aerosol process to the device, returning a // pointer to the copy. AerosolProcess * copy_to_device () const ; // On host: call this static method to delete a copy of the process // that has been created on a device. static void delete_on_device ( AerosolProcess * device_process ); protected : // Override this method if your aerosol process needs to be initialized // with information about the system. The default implementation does nothing. virtual void init_ ( const ModalAerosolConfig & config ) {} // Override this method to implement the aerosol process using the specific // parameterization for the subclass. virtual void run_ ( Real t , Real dt , const Prognostics & prognostics , const Atmosphere & atmosphere , const Diagnostics & diagnostics , Tendencies & tendencies ) const = 0 ; // Override these methods to set a parameter to a given value based on its // name. virtual void set_param_ ( const std :: string & name , int value ) {} virtual void set_param_ ( const std :: string & name , bool value ) {} virtual void set_param_ ( const std :: string & name , Real value ) {} }; In addition to the \"constructor\" function used to create an instance of a AerosolProcess and the interface functions for initializing, running, and setting parameters, the interface declares protected methods with underscores after their names. These are the methods you must override in order to define the behaviors of the aerosol process. Make sure you document any supported parameters (recognized by your set_param methods). The constructor accepts a single argument: a string containing the name of the aerosol process. This can be helpful for debugging.","title":"The Aerosol Process Interface"},{"location":"library/#digression-running-aerosol-processes-on-a-gpu","text":"Haero is designed to allow aerosol physics to be computed on CPUs or GPUs, with different levels of parallelism. Running code on a GPU is tricky, because the data it uses must be copied to memory allocated on the GPU itself. In fact, a process object itself must be allocated on the GPU in order for the code to run there. The process of allocating this memory on the GPU is esoteric and confusing. Haero solves this problem by inserting an intermediary class between your derived class and the AerosolProcess class. This intermediary class is named DeviceAerosolProcess . It uses C++'s curiously recurring template pattern to add all the necessary logic for your class to run on a GPU. The way it works is this: An object for your process class is allocated and initialized (via init ) on the CPU by an atmospheric host model. The host model calls the copy_to_device method to obtain a copy of the object that lives on the GPU. This method uses a copy constructor defined by your process class to copy itself from the CPU to the GPU. The host model invokes your GPU-resident object's run method within a Kokkos parallel dispatch as needed, passing it a Kokkos thread team that determines the number of threads available witin the method. When the calculation is finished, the host model calls the delete_on_device static method, passing it the GPU-resident object to deallocate it from the GPU. The most important thing to remember here is that init is called on the CPU, whether or not you intend to run your process on the GPU. You must use the init method to record any information from the ModalAerosolConfig object that defines your simulation, because ModalAerosolConfig variables cannot reside on the GPU. Parameters are also set (using set_param ) on the CPU, not the GPU. Let's explore how we might implement an aerosol process in C++ and in Fortran. Here we describe only the steps needed to implement the process itself. You must also test your process to make sure it behaves the way you think it does! The procedure for testing an aerosol process is described in the Testing section.","title":"Digression: running aerosol processes on a GPU"},{"location":"library/#c-aerosol-processes","text":"In C++, all you have to do in order to implement an aerosol process is to define a class with a specific name. For concreteness, let's examine a process named SimpleNucleationProcess , which lives in haero/processes/simple_nucleation_process.hpp and haero/processes/simple_nucleation_process.cpp . To allow your process to reside on a CPU or GPU, your derive your class from the DeviceAerosolProcess . This class accepts a single template parameter: your class. So in our example, you would derive SimpleNucleationProcess from DeviceAerosolProcess<SimpleNucleationProcess> . This curiously recursive trick, in which the type of the intermediary class depends on the type of its descendent, gives the Curiously Recurring Template Pattern its name. Let's not worry about how it works for now. Before we go any further, some terminology: a C++ class derived from a base class is called a subclass of that base class. So MyProcess is a subclass of DeviceAerosolProcess<SimpleNucleationProcess> , which is itself a subclass of the base class AerosolProcess . To create a C++ implemention for an aerosol process: Create a header file that declares your subclass. This header file must declare a class constructor, a copy constructor, a destructor, and the overridable init_ and run_ functions. If you want to support configurable parameters, declare whatever versions of set_param_ you need. Implement your Implement your copy constructor, your destructor, and your run_ method in the header file, declaring each with the KOKKOS_INLINE_FUNCTION macro. This allows them to be called on a GPU. Create a source file containing implementations for the remaining methods (the constructor, the init_ method, and any set_param_ methods you need). See haero/processes/simple_nucleation_process.cpp , for example. Add your source file to the set of source files in the PROCESS_SOURCES variable in haero/processes/CMakeLists.txt . Write one or more tests for your new aerosol process. The Testing section provides details about how to do this.","title":"C++ aerosol processes"},{"location":"library/#fortran-aerosol-processes","text":"A Fortran aerosol process implementation consists of a Fortran module that contains init , run , and finalize subroutines that implement the same functionality as their C++ counterparts: Fortran aerosol module module MODULE_NAME use haero , only : wp , modal_aerosol_config_t , prognostics_t , atmosphere_t , & diagnostics_t , tendencies_t ... implicit none ! Aerosol process interface subroutines public :: init , run , finalize ! Parameter setting subroutines public :: set_integer_param , set_logical_param , set_real_param ! Module variables, including settable parameters integer :: my_option logical :: my_flag real ( wp ) :: my_scale_factor ! SAVE keyword for retaining module variables save contains subroutine init ( config ) implicit none ! Arguments type ( modal_aerosol_config_t ), intent ( in ) :: config ... end subroutine subroutine run ( t , dt , prognostics , atmosphere , diagnostics , tendencies ) implicit none ! Arguments real ( wp ), value , intent ( in ) :: t real ( wp ), value , intent ( in ) :: dt type ( prognostics_t ), intent ( in ) :: prognostics type ( atmosphere_t ), intent ( in ) :: atmosphere type ( diagnostics_t ), intent ( in ) :: diagnostics type ( tendencies_t ), intent ( inout ) :: tendencies ... end subroutine subroutine finalize () implicit none ... end subroutine subroutine set_integer_param ( name , val ) implicit none ! Arguments character ( len =* ), intent ( in ) :: name integer , intent ( in ) :: val if ( trim ( name ) == \"my_option\" ) then my_option = val end if end subroutine subroutine set_logical_param ( name , val ) implicit none ! Arguments character ( len =* ), intent ( in ) :: name logical , intent ( in ) :: val if ( trim ( name ) == \"my_flag\" ) then my_flag = val end if end subroutine subroutine set_real_param ( name , val ) implicit none ! Arguments character ( len =* ), intent ( in ) :: name real ( wp ), intent ( in ) :: val if ( trim ( name ) == \"my_scale_factor\" ) then my_scale_factor = val end if end subroutine ... end module In Fortran, you must implement subroutines for set_integer_param , set_logical_param , and set_real_param , even if your process doesn't support settable parameters. To implement an aerosol process in Fortran, you create such a module in a Fortran source file and then declare it as a faerosol_process in the CMakeLists.txt file within the haero/processes subdirectory. There are instructions on how to declare your process in that file. For example, the Fortran MAM nucleation process is implemented in a Fortran module named mam_nucleation , implemented in the source file haero/processes/mam_nucleation.F90 . In haero/processes/CMakeLists.txt , it's declared as a Fortran aerosol process the following way: haero/processes/CMakeLists.txt if (HAERO_FORTRAN) ... faerosol_process(MAMNucleationFProcess NucleationProcess mam_nucleation) ... endif() The declaration takes three arguments: The name of a C++ class that will be created that exposes the Fortran implementation of the process The C++ enumerated type that identifies what kind of aerosol process is being implemented The name of the Fortran module that implements the process The build system automatically generates a C++ class for the Fortran module that allows the process to be used in a Haero simulation. The name of this C++ class is important for exposing it to the Haero library. Once you've done these things and rebuilt Haero, your new aerosol process implementation is available for use.","title":"Fortran aerosol processes"},{"location":"library/#diagnostic-functions","text":"Aerosol processes compute tendencies for prognostic variables. But how are diagnostic variables updated? These variables are quite different in nature from their prognostic counterparts: they depend algebraically on prognostic variables and other diagnostic variables they are updated in place instead of being evolved in time by differential equations they are often shared/needed by several distinct aerosol processes, and at various points in time, depending on a given process ordering Because of these considerations, it's not clear that we can update more than a single diagnostic variable at once. To do so implies a knowledge of how the aerosol processes are invoked during a time step, and Haero does not make any such decision on behalf of a host model. This means we must provide a diagnostic variable update mechanism that is flexible but easy to understand. This mechanism, which updates a single diagnostic variable, is called a diagnostic function . Unlike aerosol processes, which have multiple behaviors associated with initialization, finalization, and the execution of the process itself, a diagnostic function only ever does one thing: it takes a set of input and uses it to update its diagnostic variable. In other words, it has no internal state of its own---it's just a function that you can call whenever you need to update a particular diagnostic variable.","title":"Diagnostic Functions"},{"location":"physics/","text":"Aerosol Physics \\[ \\renewcommand{\\d}[1]{\\mathrm{d} #1} \\renewcommand{\\vec}[1]{\\mathbf{#1}} \\newcommand{\\ddt}[1]{\\frac{d #1}{dt}} \\newcommand{\\partialt}[1]{\\frac{\\partial #1}{\\partial t}} \\renewcommand{\\div}[1]{\\nabla \\cdot #1} \\newcommand{\\dsub}[1]{_{_{#1}}} \\newcommand{\\specidx}{L} \\newcommand{\\amass}[1]{q\\dsub{m,#1,i}} \\newcommand{\\aitmass}[1]{q_{_{m,#1,2}}} \\newcommand{\\vmass}[1]{q\\dsub{v,#1}} \\newcommand{\\mw}[1]{M\\dsub{w,#1}} \\newcommand{\\rsag}{\\rm H_{_2}SO_{_4}} \\newcommand{\\rasf}{\\rm SO_{_4}} \\newcommand{\\rwater}{\\rm H_{_2}O} \\newcommand{\\sag}{H_{_2}SO_{_4}} \\newcommand{\\asf}{SO_{_4}} \\newcommand{\\water}{H_{_2}O} \\newcommand{\\numc}{N_{_{t,i}}} \\newcommand{\\pluseq}{\\mathrel{+}=} \\newcommand{\\minuseq}{\\mathrel{-}=} \\DeclareMathOperator{\\sgn}{sgn} \\newcommand{\\dsub}[1]{_{_{#1}}} \\newcommand{\\specidx}{L} \\newcommand{\\amass}[1]{q\\dsub{m,#1,i}} \\newcommand{\\vmass}[1]{q\\dsub{v,#1}} \\newcommand{\\mw}[1]{M\\dsub{w,#1}} \\newcommand{\\rsag}{\\rm H_2SO_4} \\newcommand{\\sag}{H_2SO_4} \\newcommand{\\rasf}{\\rm SO_4} \\newcommand{\\asf}{SO_4} \\] Here we describe the physics of aerosols as represented by the modal aerosol model. First, we review the modal aerosol approximation, which defines the equations and quantites of interest and describes how various aerosol processes are parameterized. Then we describe in detail these various parameterized aerosol processes, their physical significance, and their mathematical represention. Along the way, we take care to highlight any physical, statistical, and mathematical assumptions, to make clear the circumstances under which Haero's aerosol model is valid. The Modal Aerosol Approximation Here we offer an extremely abbreviated \"fly-over\" of the evolution equations that quantify the dynamics of aerosols. Here, we emphasize the mathematical representation of aerosols. For a more detailed explanation of the underlying ideas, we refer the reader to~\\cite{Whitby1991} and~\\cite{Friedlander1977}. All quantities are in SI units unless specifically mentioned. To keep the discussion simple and focused, we avoid referencing specific coordinates. Many of the assumptions here are inherited from Dick Easter's Modal Aerosol Model 4-mode (MAM4) model. Size Matters The modal approach to modeling aerosols is based on the observations that the sizes of aerosol particles greatly influence their dynamical behavior these sizes span several orders of magnitude (from 0.001 to 100 microns) Here, a \"particle\" is an individual aerosol molecule with some volume \\(V_p\\) . Aerosol particles consist of polymers, and a particle consisting of a chain of \\(i\\) monomers is an \\(i\\) -mer. How do we represent a set of aerosol particles in space, given the importance of their size? In the simplest case (for small \\(i\\) -mers), we can denote \\(N_i(\\vec{x}, t)\\) as the number of \\(i\\) -mers per cubic meter in the vicinity of the point \\(\\vec{x}\\) at time \\(t\\) . In this language, the evolution equation is a set of coupled advection-diffusion-reaction (ADR) equations acting under the influence of a bulk velocity \\(\\vec{v}\\) : \\[ \\begin{equation} \\partialt{N_i} + \\nabla\\cdot{(N_i\\vec{v})} = \\mathcal{D}(\\nabla N_i) + \\mathcal{R}(\\{N_j\\}) + \\mathcal{S}(N_i, t) \\label{small_imer_dNdt} \\end{equation} \\] Here we represent terms on the right hand side by \\(\\mathcal{D}\\) : terms related to {\\it diffusion processes} for \\(N_i\\) \\(\\mathcal{R}\\) : terms related to {\\it reaction processes}, in which various \\(j\\) -mers combine, react, and dissociate to form particles of other types \\(\\mathcal{S}\\) : terms related to {\\it source and sink processes}, including external and prescribed sources of \\(N_i\\) . We describe the forms of these terms in Processes . The bulk velocity \\(\\vec{v}\\) is supplied by some dynamical atmospheric model. For larger \\(i\\) -mers ( \\(i > 100\\) ), the above description becomes inadequate, and we must adopt a description for particle numbers that admits a continuous number distribution in particle size space. Let \\(n(V_p, \\vec{x}, t)\\) be the number of particles of volume \\(V_p\\) occupying the point \\(\\vec{x}\\) at time \\(t\\) . Then the evolution of all \\(i\\) -mers is described by a single ADR equation: \\[\\begin{equation} \\partialt{n} + \\div{(n\\vec{v})} = \\mathcal{D}(\\nabla n) + \\mathcal{R}(n) + \\mathcal{S}(n, t) \\label{continuous_dndt} \\end{equation}\\] where \\(\\mathcal{D}\\) , \\(\\mathcal{R}\\) , and \\(\\mathcal{S}\\) have been expressed in terms of \\(n\\) instead of \\(N_i\\) . This is a tidy equation, but \\(n\\) is a number distribution function that introduces a new dimension---the particle volume \\(V_p\\) ---to the solution space. This makes it inconvenient for doing numerical calculations. In this description, \\(n\\) can assume any shape in particle volume space, which raises the question of how to constrain the solution in \\(V_p\\) . Moment Equations and the Closure Problem We can reduce the size of our solution space by making a few assumptions: Assumption The detailed structure of the number distribution function \\(n(V_p, \\vec{x}, t)\\) is unimportant to aerosol dynamics. If we don't need to obtain the full solution for \\(n\\) , we can select a specific functional form \\(n(D_p, \\vec{x}, t) = n(\\vec{x}, t; D_p)\\) for it. Then, taking cues from methods in particle kinetics and turbulence theory, we can integrate the product of \\refeq{continuous_dndt} with powers of \\(D_p\\) to obtain the {\\bf moment equations} \\[\\begin{equation}\\label{moments} \\partialt{\\mathcal{M}_k} + \\div{(\\mathcal{M}_k\\vec{v})} = \\int_0^{\\infty} D_p^k (\\mathcal{D} + \\mathcal{R} + \\mathcal{S}) \\d{D_p} \\end{equation}\\] where \\(\\mathcal{M}_k(\\vec{x}, t) = \\int_0^{\\infty} D_p^k n(\\vec{x}, t; D_p) \\d{D_p}\\) is the `` \\(k\\) th moment'' of \\(n\\) . The moment equations are solved by picking a specific form of \\(n\\) 's functional dependence on \\(D_p\\) and playing tricks to avoid actually evaluating the above integrals. However, the moment equations aren't closed---the advection, diffusion, reaction, and source terms can all involve \\(n\\) and its spatial derivatives, and in general, the evolution of \\(\\mathcal{M}_k\\) is coupled to higher moments. To make further progress, we must solve this {\\bf closure problem}. Modal Equations Having already given up on obtaining a general solution for \\(n(\\vec{x}, t)\\) , we allow ourselves to make another assumption: Modal assumption The number distribution function \\(n\\) is the sum of a set of specific number distribution functions \\(n_i\\) , each representing a {\\bf mode} with a specific functional form for a sub-population of aerosol particles occupying a certain range in particle size space. In other words, \\[\\begin{equation} n(\\vec{x}, t; D_p) = \\sum_{i=1}^M n_i(\\vec{x}, t; D_p) \\label{modal_n} \\end{equation}\\] where \\(n_i\\) represents aerosol particles with sizes falling within the range of mode \\(i\\) and \\(M\\) is the number of modes. Each mode assumes a specific functional form for \\(n_i\\) in terms of its relevant size as given by \\(D_p\\) . We include the arguments \\(\\vec{x}\\) and \\(t\\) to emphasize that this equation holds at each point in space and at each instant in time for an aerosol system. Log-Normal Distribution Functions Haero constructs its multi-modal distribution functions from log-normal probability distribution functions (PDFs) for each mode \\(i\\) . The PDF for mode \\(i\\) expresses the fraction of aerosol particles present per unit size interval, in terms of a continuous particle diameter \\(D_p\\) within that mode. Such PDFs have been found to represent measured aerosol size distributions with a level of accuracy comparable to that of the relevant measurement techniques~\\cite{Whitby1991}. Log-normal PDF The probability distribution function \\(f_i\\) used to construct the number distribution function \\(n_i\\) for mode \\(i\\) is a continuous function of the particle diameter \\(D_p\\) , given as a log-normal distribution, \\begin{equation}\\label{log_normal_pdf} f_i(D_p) = \\frac{1}{\\sqrt{2\\pi} D_p \\ln \\sigma_{g,i}} \\ \\exp \\left [-\\frac{(\\ln D_p - \\ln D_{g,i})^2}{2\\ln^2 \\sigma_{g,i}} \\right] \\end{equation} where we have introduced the geometric mean \\(D_{g,i}\\) and the geometric standard deviation \\(\\sigma_{g,i}\\) of \\(D_p\\) within mode \\(i\\) . In general, these two parameters are determined for each mode via moment equations and corresponding time-evolution equations. Haero makes an additional simplifying assumption: Constant standard deviation The geometric standard deviation \\(\\sigma_{g,i}>1\\) for each mode \\(i\\) is constant in time. The justification for this assumption in \\cite{Easter2004,Wilson2001,Whitby1991} is given in \\cite{Whitby1981}. This PDF can also be expressed in \"logarithmic form\" in terms of \\(\\ln D_p\\) of \\(D_p\\) : \\[\\begin{equation}\\label{log_normal_pdf_log} g_i(\\ln D_p) = \\frac{1}{\\sqrt{2\\pi} \\ln\\sigma_{g,i}} \\ \\exp \\left [ -\\frac{(\\ln D_p - \\ln D_{g,i})^2}{2\\ln^2 \\sigma_{g,i}} \\right] \\end{equation}\\] Here, \\(g_i\\) is a normal distribution of \\(\\ln D_p\\) with a mean of \\(\\ln D_{g,i}\\) and standard deviation of \\(\\ln\\sigma_{g,i}\\) . These PDFs are referred to as {\\bf normalized size distribution functions} in Haero. We can justify this name by multiplying each PDF by the total particle number density \\(N_i\\) for mode \\(i\\) to obtain the equivalent number distribution functions: \\[\\begin{align}\\label{log_normal_n} n_i(D_p) = N_i f_i(D_p) &= \\frac{N_i}{\\sqrt{2\\pi} D_p \\ln \\sigma_{g,i}} \\ \\exp \\left [ - \\frac{(\\ln D_p - \\ln D_{g,i})^2}{2\\ln^2\\sigma_{g,i}} \\right ] \\\\ \\hat{n}_{i}(\\ln D_p) = N_i g_i(\\ln D_p) &= \\frac{N_i}{\\sqrt{2\\pi}\\ln \\sigma_{g,i}} \\ \\exp \\left [ - \\frac{(\\ln D_p - \\ln D_{g,i})^2}{2\\ln^2\\sigma_{g,i}} \\right ] \\end{align}\\] The logarithmic form \\(\\hat{n}_i\\) is useful because of the relationship $ n_i(D_p) = \\hat{n}_i(\\ln D_p)/D_p$, which allows us to write \\[\\begin{equation} \\label{equ_norm_lognorm} n_i(D_p) \\d{D_p} = \\hat{n}_i(\\ln D_p) \\d{\\ln D_p} \\end{equation}\\] to simplify integrands involving number distribution functions. The benefit of this log-normal functional form choice is that the moment integrals can be defined analytically, obviating the need for potentially costly numerical quadrature \\cite[eqns.~(3.7)]{Whitby1991}. The \\(k\\) th moment is given in this case by, \\[\\begin{equation} M_k^{(i)} = N_i D_{g,i}^k \\exp\\left(\\frac{k^2}{2}\\log^2\\sigma_{g,i}\\right). \\end{equation}\\] In particular, \\[\\begin{align} M_0^{(i)} &= \\int_0^\\infty n_i(D_p)\\,d D_p = N_i, \\label{eq:zero_moment}\\\\ M_1^{(i)} &= \\int_0^\\infty D_p n_i(D_p)\\,d D_p = N_iD_{g,i}\\exp({\\frac{1}{2}\\log^2\\sigma_{g,i}}),\\\\ M_2^{(i)} &= \\int_0^\\infty D_p^2n_i(D_p)\\,d D_p = N_iD_{g,i}^2\\exp(2\\log^2\\sigma_{g,i}),\\\\ M_3^{(i)} &= \\int_0^\\infty D_p^3n_i(D_p)\\,d D_p = N_iD_{g,i}^3\\exp(\\frac{9}{2}\\log^2\\sigma_{g,i}) \\label{eq:third_moment} \\end{align}\\] Particle size Particle size \\(\\overline{D_i}\\) for the \\(i\\) th mode is defined by the mean diameter associated with the 3rd moment \\cite[eqn.~(1)]{Whitby1981}, \\begin{equation} \\overline{D_i} = \\left(M_3^{(i)}/N_i)\\right)^{1/3} = D_{g,i}\\exp\\left(\\frac{3}{2}\\log^2\\sigma_{g,i}\\right) \\end{equation} Particles have spherical shapes Aerosol particles are spherical, and their size can be parameterized by their diameter \\(\\overline{D_i}\\) . Corollaries for area and volume follow ( \\(\\overline{A_i} = \\pi\\overline{D_i}^2\\) , \\(\\overline{V_i} = \\frac{\\pi}{6}\\overline{D_i}^3\\) ). When we adopt the log-normal assumption, we express our solution for particles in mode \\(i\\) in terms of its zeroth, first, second, and third moments \\(\\mathcal{M}_k^{(i)}(\\vec{x}, t)\\) . These are, respectively: \\(\\mathcal{M}_0^{(i)} = N_i\\) , the total number of concentration for particles in mode \\(i\\) \\(\\mathcal{M}_1^{(i)} = N_i\\overline{D}_i\\) , the number-weighted mean diameter of particles in mode \\(i\\) \\(\\mathcal{M}_2^{(i)} = \\frac{1}{\\pi}N_i\\overline{A}_i\\) , a number-weighted surface area of particles in mode \\(i\\) \\(\\mathcal{M}_3^{(i)} = \\frac{6}{\\pi}N_i\\overline{V}_i\\) , a number-weighted volume of particles in mode \\(i\\) In this language, the aerosol evolution equation for the \\(k\\) th moment of the \\(i\\) th mode is \\[\\begin{equation}\\label{modal_evolution} \\partialt{\\mathcal{M}_k^{(i)}} = F_k^{(i)}(N_i, \\overline{D}_i, \\overline{A}_i, \\overline{V}_i, T, p, \\mathsf{...}) \\end{equation}\\] where the air temperature \\(T\\) and the air pressure \\(p\\) enter the moment equations, via right hand side terms in \\ref{moments}. These are the modal equations . Parmeterization assumption The time evolution of a moment \\(\\mathcal{M}_k^{(i)}\\) can be expressed in terms of the quantities \\(N_i\\) , \\(\\overline{D}_i\\) , \\(\\overline{A}_i\\) , \\(\\overline{V}_i\\) , the air temperature \\(T\\) , the pressure \\(p\\) , and a few selected additional quantities. 2-moment scheme Aerosol dynamics can be represented well by two moments, \\(M_0^{(i)}\\) and \\(M_3^{(i)}\\) . We must find equations that describe the time evolution of \\(M_0^{(i)}\\) and \\(M_3^{(i)}\\) in terms of known E3SM variables. Modal number concentrations \\(N_m\\) are defined and transported for each mode [# / kg air] as prognostic model variables (tracers). These are the \\(\\mathcal{M}_0\\) moments for each mode, \\ref{zero_moment}. Mass mixing ratios \\(q_{s,m}\\) are defined for each species \\(s\\) in each mode \\(m\\) [ kg aerosol / kg air ] as prognostic model variables (tracers). Therefore, the third moments \\(\\mathcal{M}_3\\) of each mode are found using the density of each aerosols species. Volume mixing ratios are diagnosed by \\(V_{s,m} = q_{s,m}/\\rho_{s,m}\\) [m \\(^3\\) aerosol / kg air], where \\(\\rho_{s,m}\\) is the constant species density [kg aerosol / m \\(^3\\) ]. Mode definitions in MAM4 The choices of size range and width for the modes in MAM are based on measurements of tropospheric aerosols (see~\\cite{Easter2004} and references therein). Here are the relevant parameters for MAM4, the 4-mode legacy MAM model. Mode Lower bound of \\(D\\dsub{gn,d,i}\\) Upper bound of \\(D\\dsub{gn,d,i}\\) \\(\\sigma\\dsub{g,i}\\) \\(N_i(0)\\) Aitken 0.0087 0.052 1.6 7.9031E7 Accumulation 0.0535 0.44 1.8 7.9697E7 Coarse 1.0 4.0 1.8 8.0361E7 Primary carbon 0.01 0.1 1.6 8.1022E7 Thus, in MAM, all modes have the same mathematical form, but the parameters are different for each mode. Multi-Species Modes We have derived the modal equations assuming that each mode contains a population of undifferentiated aerosol particles. We assume that each particle is composed of several (potentially different) chemical species: Internally mixed All aerosol species within a mode are assumed to be carried uniformly by all particles represented by the mode's log-normal distribution function, i.e., within each mode, particles are internally mixed. Additive particle volume Quantitatively, the internal mixing assumption implies that the volume of each individual particle is the sum of the volumes of its various constituents; in this case, the species within the mode. These assumptions lead to the following modal averages. Mode aerosol mass mixing ratio The mass mixing ratio of species \\(s\\) in mode \\(m\\) is denoted by \\(q_{sm}\\) . The mass mixing ration of the mode [kg aerosol / kg air] is then \\begin{equation}\\label{mode_mixing_ratio} q_{m} = \\sum_{s\\in m} q_{sm}. \\end{equation} Modally averaged aerosol density The density of aerosol species \\(s\\) in mode \\(m\\) is denoted \\(\\rho_{sm}\\) . The average modal density [kg aerosol / m \\(^3\\) aerosol] is \\begin{equation}\\label{mode_density} \\rho_m = \\sum_{s\\in m}q_{sm} \\rho_{sm} \\left(\\sum_{s\\in m} q_{sm}\\right)^{-1} = \\frac{\\sum_{s\\in m}q_{sm}\\rho_{sm}}{q_m}. \\end{equation} Modally averaged hygroscopicity The hygroscopicity of species \\(s\\) in mode \\(m\\) is denoted \\(b_{sm}\\) . The mode-averaged hygroscopicity [-] is \\begin{equation}\\label{mode_hygro} b_m = \\sum_{s\\in m} \\frac{q_{sm} b_{sm}}{\\rho_{sm}}\\left(\\sum_{s\\in m} \\frac{q_{sm}}{\\rho_{sm}}\\right)^{-1}. \\end{equation} Modal mean particle volume The per-particle mean volume for each mode \\(m\\) [m \\(^3\\) /particle] is \\begin{equation}\\label{mode_particle_volume} {V_{m}} = \\frac{1}{N_m}\\sum_{s\\in m} \\frac{q_{sm}}{\\rho_{sm}}. \\end{equation} Modal geometric mean particle diameter The geometric mean diameter of the particles in mode \\(m\\) [m] is \\begin{equation}\\label{mode_particle_diameter} {D_{m}} = \\sqrt[3]{\\frac{\\pi}{6}{V_{Pm}}}\\exp\\left(-\\frac{3}{2}\\log^2 \\sigma_m\\right). \\end{equation}","title":"Aerosol Physics"},{"location":"physics/#aerosol-physics","text":"\\[ \\renewcommand{\\d}[1]{\\mathrm{d} #1} \\renewcommand{\\vec}[1]{\\mathbf{#1}} \\newcommand{\\ddt}[1]{\\frac{d #1}{dt}} \\newcommand{\\partialt}[1]{\\frac{\\partial #1}{\\partial t}} \\renewcommand{\\div}[1]{\\nabla \\cdot #1} \\newcommand{\\dsub}[1]{_{_{#1}}} \\newcommand{\\specidx}{L} \\newcommand{\\amass}[1]{q\\dsub{m,#1,i}} \\newcommand{\\aitmass}[1]{q_{_{m,#1,2}}} \\newcommand{\\vmass}[1]{q\\dsub{v,#1}} \\newcommand{\\mw}[1]{M\\dsub{w,#1}} \\newcommand{\\rsag}{\\rm H_{_2}SO_{_4}} \\newcommand{\\rasf}{\\rm SO_{_4}} \\newcommand{\\rwater}{\\rm H_{_2}O} \\newcommand{\\sag}{H_{_2}SO_{_4}} \\newcommand{\\asf}{SO_{_4}} \\newcommand{\\water}{H_{_2}O} \\newcommand{\\numc}{N_{_{t,i}}} \\newcommand{\\pluseq}{\\mathrel{+}=} \\newcommand{\\minuseq}{\\mathrel{-}=} \\DeclareMathOperator{\\sgn}{sgn} \\newcommand{\\dsub}[1]{_{_{#1}}} \\newcommand{\\specidx}{L} \\newcommand{\\amass}[1]{q\\dsub{m,#1,i}} \\newcommand{\\vmass}[1]{q\\dsub{v,#1}} \\newcommand{\\mw}[1]{M\\dsub{w,#1}} \\newcommand{\\rsag}{\\rm H_2SO_4} \\newcommand{\\sag}{H_2SO_4} \\newcommand{\\rasf}{\\rm SO_4} \\newcommand{\\asf}{SO_4} \\] Here we describe the physics of aerosols as represented by the modal aerosol model. First, we review the modal aerosol approximation, which defines the equations and quantites of interest and describes how various aerosol processes are parameterized. Then we describe in detail these various parameterized aerosol processes, their physical significance, and their mathematical represention. Along the way, we take care to highlight any physical, statistical, and mathematical assumptions, to make clear the circumstances under which Haero's aerosol model is valid.","title":"Aerosol Physics"},{"location":"physics/#the-modal-aerosol-approximation","text":"Here we offer an extremely abbreviated \"fly-over\" of the evolution equations that quantify the dynamics of aerosols. Here, we emphasize the mathematical representation of aerosols. For a more detailed explanation of the underlying ideas, we refer the reader to~\\cite{Whitby1991} and~\\cite{Friedlander1977}. All quantities are in SI units unless specifically mentioned. To keep the discussion simple and focused, we avoid referencing specific coordinates. Many of the assumptions here are inherited from Dick Easter's Modal Aerosol Model 4-mode (MAM4) model.","title":"The Modal Aerosol Approximation"},{"location":"physics/#size-matters","text":"The modal approach to modeling aerosols is based on the observations that the sizes of aerosol particles greatly influence their dynamical behavior these sizes span several orders of magnitude (from 0.001 to 100 microns) Here, a \"particle\" is an individual aerosol molecule with some volume \\(V_p\\) . Aerosol particles consist of polymers, and a particle consisting of a chain of \\(i\\) monomers is an \\(i\\) -mer. How do we represent a set of aerosol particles in space, given the importance of their size? In the simplest case (for small \\(i\\) -mers), we can denote \\(N_i(\\vec{x}, t)\\) as the number of \\(i\\) -mers per cubic meter in the vicinity of the point \\(\\vec{x}\\) at time \\(t\\) . In this language, the evolution equation is a set of coupled advection-diffusion-reaction (ADR) equations acting under the influence of a bulk velocity \\(\\vec{v}\\) : \\[ \\begin{equation} \\partialt{N_i} + \\nabla\\cdot{(N_i\\vec{v})} = \\mathcal{D}(\\nabla N_i) + \\mathcal{R}(\\{N_j\\}) + \\mathcal{S}(N_i, t) \\label{small_imer_dNdt} \\end{equation} \\] Here we represent terms on the right hand side by \\(\\mathcal{D}\\) : terms related to {\\it diffusion processes} for \\(N_i\\) \\(\\mathcal{R}\\) : terms related to {\\it reaction processes}, in which various \\(j\\) -mers combine, react, and dissociate to form particles of other types \\(\\mathcal{S}\\) : terms related to {\\it source and sink processes}, including external and prescribed sources of \\(N_i\\) . We describe the forms of these terms in Processes . The bulk velocity \\(\\vec{v}\\) is supplied by some dynamical atmospheric model. For larger \\(i\\) -mers ( \\(i > 100\\) ), the above description becomes inadequate, and we must adopt a description for particle numbers that admits a continuous number distribution in particle size space. Let \\(n(V_p, \\vec{x}, t)\\) be the number of particles of volume \\(V_p\\) occupying the point \\(\\vec{x}\\) at time \\(t\\) . Then the evolution of all \\(i\\) -mers is described by a single ADR equation: \\[\\begin{equation} \\partialt{n} + \\div{(n\\vec{v})} = \\mathcal{D}(\\nabla n) + \\mathcal{R}(n) + \\mathcal{S}(n, t) \\label{continuous_dndt} \\end{equation}\\] where \\(\\mathcal{D}\\) , \\(\\mathcal{R}\\) , and \\(\\mathcal{S}\\) have been expressed in terms of \\(n\\) instead of \\(N_i\\) . This is a tidy equation, but \\(n\\) is a number distribution function that introduces a new dimension---the particle volume \\(V_p\\) ---to the solution space. This makes it inconvenient for doing numerical calculations. In this description, \\(n\\) can assume any shape in particle volume space, which raises the question of how to constrain the solution in \\(V_p\\) .","title":"Size Matters"},{"location":"physics/#moment-equations-and-the-closure-problem","text":"We can reduce the size of our solution space by making a few assumptions: Assumption The detailed structure of the number distribution function \\(n(V_p, \\vec{x}, t)\\) is unimportant to aerosol dynamics. If we don't need to obtain the full solution for \\(n\\) , we can select a specific functional form \\(n(D_p, \\vec{x}, t) = n(\\vec{x}, t; D_p)\\) for it. Then, taking cues from methods in particle kinetics and turbulence theory, we can integrate the product of \\refeq{continuous_dndt} with powers of \\(D_p\\) to obtain the {\\bf moment equations} \\[\\begin{equation}\\label{moments} \\partialt{\\mathcal{M}_k} + \\div{(\\mathcal{M}_k\\vec{v})} = \\int_0^{\\infty} D_p^k (\\mathcal{D} + \\mathcal{R} + \\mathcal{S}) \\d{D_p} \\end{equation}\\] where \\(\\mathcal{M}_k(\\vec{x}, t) = \\int_0^{\\infty} D_p^k n(\\vec{x}, t; D_p) \\d{D_p}\\) is the `` \\(k\\) th moment'' of \\(n\\) . The moment equations are solved by picking a specific form of \\(n\\) 's functional dependence on \\(D_p\\) and playing tricks to avoid actually evaluating the above integrals. However, the moment equations aren't closed---the advection, diffusion, reaction, and source terms can all involve \\(n\\) and its spatial derivatives, and in general, the evolution of \\(\\mathcal{M}_k\\) is coupled to higher moments. To make further progress, we must solve this {\\bf closure problem}.","title":"Moment Equations and the Closure Problem"},{"location":"physics/#modal-equations","text":"Having already given up on obtaining a general solution for \\(n(\\vec{x}, t)\\) , we allow ourselves to make another assumption: Modal assumption The number distribution function \\(n\\) is the sum of a set of specific number distribution functions \\(n_i\\) , each representing a {\\bf mode} with a specific functional form for a sub-population of aerosol particles occupying a certain range in particle size space. In other words, \\[\\begin{equation} n(\\vec{x}, t; D_p) = \\sum_{i=1}^M n_i(\\vec{x}, t; D_p) \\label{modal_n} \\end{equation}\\] where \\(n_i\\) represents aerosol particles with sizes falling within the range of mode \\(i\\) and \\(M\\) is the number of modes. Each mode assumes a specific functional form for \\(n_i\\) in terms of its relevant size as given by \\(D_p\\) . We include the arguments \\(\\vec{x}\\) and \\(t\\) to emphasize that this equation holds at each point in space and at each instant in time for an aerosol system.","title":"Modal Equations"},{"location":"physics/#log-normal-distribution-functions","text":"Haero constructs its multi-modal distribution functions from log-normal probability distribution functions (PDFs) for each mode \\(i\\) . The PDF for mode \\(i\\) expresses the fraction of aerosol particles present per unit size interval, in terms of a continuous particle diameter \\(D_p\\) within that mode. Such PDFs have been found to represent measured aerosol size distributions with a level of accuracy comparable to that of the relevant measurement techniques~\\cite{Whitby1991}. Log-normal PDF The probability distribution function \\(f_i\\) used to construct the number distribution function \\(n_i\\) for mode \\(i\\) is a continuous function of the particle diameter \\(D_p\\) , given as a log-normal distribution, \\begin{equation}\\label{log_normal_pdf} f_i(D_p) = \\frac{1}{\\sqrt{2\\pi} D_p \\ln \\sigma_{g,i}} \\ \\exp \\left [-\\frac{(\\ln D_p - \\ln D_{g,i})^2}{2\\ln^2 \\sigma_{g,i}} \\right] \\end{equation} where we have introduced the geometric mean \\(D_{g,i}\\) and the geometric standard deviation \\(\\sigma_{g,i}\\) of \\(D_p\\) within mode \\(i\\) . In general, these two parameters are determined for each mode via moment equations and corresponding time-evolution equations. Haero makes an additional simplifying assumption: Constant standard deviation The geometric standard deviation \\(\\sigma_{g,i}>1\\) for each mode \\(i\\) is constant in time. The justification for this assumption in \\cite{Easter2004,Wilson2001,Whitby1991} is given in \\cite{Whitby1981}. This PDF can also be expressed in \"logarithmic form\" in terms of \\(\\ln D_p\\) of \\(D_p\\) : \\[\\begin{equation}\\label{log_normal_pdf_log} g_i(\\ln D_p) = \\frac{1}{\\sqrt{2\\pi} \\ln\\sigma_{g,i}} \\ \\exp \\left [ -\\frac{(\\ln D_p - \\ln D_{g,i})^2}{2\\ln^2 \\sigma_{g,i}} \\right] \\end{equation}\\] Here, \\(g_i\\) is a normal distribution of \\(\\ln D_p\\) with a mean of \\(\\ln D_{g,i}\\) and standard deviation of \\(\\ln\\sigma_{g,i}\\) . These PDFs are referred to as {\\bf normalized size distribution functions} in Haero. We can justify this name by multiplying each PDF by the total particle number density \\(N_i\\) for mode \\(i\\) to obtain the equivalent number distribution functions: \\[\\begin{align}\\label{log_normal_n} n_i(D_p) = N_i f_i(D_p) &= \\frac{N_i}{\\sqrt{2\\pi} D_p \\ln \\sigma_{g,i}} \\ \\exp \\left [ - \\frac{(\\ln D_p - \\ln D_{g,i})^2}{2\\ln^2\\sigma_{g,i}} \\right ] \\\\ \\hat{n}_{i}(\\ln D_p) = N_i g_i(\\ln D_p) &= \\frac{N_i}{\\sqrt{2\\pi}\\ln \\sigma_{g,i}} \\ \\exp \\left [ - \\frac{(\\ln D_p - \\ln D_{g,i})^2}{2\\ln^2\\sigma_{g,i}} \\right ] \\end{align}\\] The logarithmic form \\(\\hat{n}_i\\) is useful because of the relationship $ n_i(D_p) = \\hat{n}_i(\\ln D_p)/D_p$, which allows us to write \\[\\begin{equation} \\label{equ_norm_lognorm} n_i(D_p) \\d{D_p} = \\hat{n}_i(\\ln D_p) \\d{\\ln D_p} \\end{equation}\\] to simplify integrands involving number distribution functions. The benefit of this log-normal functional form choice is that the moment integrals can be defined analytically, obviating the need for potentially costly numerical quadrature \\cite[eqns.~(3.7)]{Whitby1991}. The \\(k\\) th moment is given in this case by, \\[\\begin{equation} M_k^{(i)} = N_i D_{g,i}^k \\exp\\left(\\frac{k^2}{2}\\log^2\\sigma_{g,i}\\right). \\end{equation}\\] In particular, \\[\\begin{align} M_0^{(i)} &= \\int_0^\\infty n_i(D_p)\\,d D_p = N_i, \\label{eq:zero_moment}\\\\ M_1^{(i)} &= \\int_0^\\infty D_p n_i(D_p)\\,d D_p = N_iD_{g,i}\\exp({\\frac{1}{2}\\log^2\\sigma_{g,i}}),\\\\ M_2^{(i)} &= \\int_0^\\infty D_p^2n_i(D_p)\\,d D_p = N_iD_{g,i}^2\\exp(2\\log^2\\sigma_{g,i}),\\\\ M_3^{(i)} &= \\int_0^\\infty D_p^3n_i(D_p)\\,d D_p = N_iD_{g,i}^3\\exp(\\frac{9}{2}\\log^2\\sigma_{g,i}) \\label{eq:third_moment} \\end{align}\\] Particle size Particle size \\(\\overline{D_i}\\) for the \\(i\\) th mode is defined by the mean diameter associated with the 3rd moment \\cite[eqn.~(1)]{Whitby1981}, \\begin{equation} \\overline{D_i} = \\left(M_3^{(i)}/N_i)\\right)^{1/3} = D_{g,i}\\exp\\left(\\frac{3}{2}\\log^2\\sigma_{g,i}\\right) \\end{equation} Particles have spherical shapes Aerosol particles are spherical, and their size can be parameterized by their diameter \\(\\overline{D_i}\\) . Corollaries for area and volume follow ( \\(\\overline{A_i} = \\pi\\overline{D_i}^2\\) , \\(\\overline{V_i} = \\frac{\\pi}{6}\\overline{D_i}^3\\) ). When we adopt the log-normal assumption, we express our solution for particles in mode \\(i\\) in terms of its zeroth, first, second, and third moments \\(\\mathcal{M}_k^{(i)}(\\vec{x}, t)\\) . These are, respectively: \\(\\mathcal{M}_0^{(i)} = N_i\\) , the total number of concentration for particles in mode \\(i\\) \\(\\mathcal{M}_1^{(i)} = N_i\\overline{D}_i\\) , the number-weighted mean diameter of particles in mode \\(i\\) \\(\\mathcal{M}_2^{(i)} = \\frac{1}{\\pi}N_i\\overline{A}_i\\) , a number-weighted surface area of particles in mode \\(i\\) \\(\\mathcal{M}_3^{(i)} = \\frac{6}{\\pi}N_i\\overline{V}_i\\) , a number-weighted volume of particles in mode \\(i\\) In this language, the aerosol evolution equation for the \\(k\\) th moment of the \\(i\\) th mode is \\[\\begin{equation}\\label{modal_evolution} \\partialt{\\mathcal{M}_k^{(i)}} = F_k^{(i)}(N_i, \\overline{D}_i, \\overline{A}_i, \\overline{V}_i, T, p, \\mathsf{...}) \\end{equation}\\] where the air temperature \\(T\\) and the air pressure \\(p\\) enter the moment equations, via right hand side terms in \\ref{moments}. These are the modal equations . Parmeterization assumption The time evolution of a moment \\(\\mathcal{M}_k^{(i)}\\) can be expressed in terms of the quantities \\(N_i\\) , \\(\\overline{D}_i\\) , \\(\\overline{A}_i\\) , \\(\\overline{V}_i\\) , the air temperature \\(T\\) , the pressure \\(p\\) , and a few selected additional quantities. 2-moment scheme Aerosol dynamics can be represented well by two moments, \\(M_0^{(i)}\\) and \\(M_3^{(i)}\\) . We must find equations that describe the time evolution of \\(M_0^{(i)}\\) and \\(M_3^{(i)}\\) in terms of known E3SM variables. Modal number concentrations \\(N_m\\) are defined and transported for each mode [# / kg air] as prognostic model variables (tracers). These are the \\(\\mathcal{M}_0\\) moments for each mode, \\ref{zero_moment}. Mass mixing ratios \\(q_{s,m}\\) are defined for each species \\(s\\) in each mode \\(m\\) [ kg aerosol / kg air ] as prognostic model variables (tracers). Therefore, the third moments \\(\\mathcal{M}_3\\) of each mode are found using the density of each aerosols species. Volume mixing ratios are diagnosed by \\(V_{s,m} = q_{s,m}/\\rho_{s,m}\\) [m \\(^3\\) aerosol / kg air], where \\(\\rho_{s,m}\\) is the constant species density [kg aerosol / m \\(^3\\) ].","title":"Log-Normal Distribution Functions"},{"location":"physics/#mode-definitions-in-mam4","text":"The choices of size range and width for the modes in MAM are based on measurements of tropospheric aerosols (see~\\cite{Easter2004} and references therein). Here are the relevant parameters for MAM4, the 4-mode legacy MAM model. Mode Lower bound of \\(D\\dsub{gn,d,i}\\) Upper bound of \\(D\\dsub{gn,d,i}\\) \\(\\sigma\\dsub{g,i}\\) \\(N_i(0)\\) Aitken 0.0087 0.052 1.6 7.9031E7 Accumulation 0.0535 0.44 1.8 7.9697E7 Coarse 1.0 4.0 1.8 8.0361E7 Primary carbon 0.01 0.1 1.6 8.1022E7 Thus, in MAM, all modes have the same mathematical form, but the parameters are different for each mode.","title":"Mode definitions in MAM4"},{"location":"physics/#multi-species-modes","text":"We have derived the modal equations assuming that each mode contains a population of undifferentiated aerosol particles. We assume that each particle is composed of several (potentially different) chemical species: Internally mixed All aerosol species within a mode are assumed to be carried uniformly by all particles represented by the mode's log-normal distribution function, i.e., within each mode, particles are internally mixed. Additive particle volume Quantitatively, the internal mixing assumption implies that the volume of each individual particle is the sum of the volumes of its various constituents; in this case, the species within the mode. These assumptions lead to the following modal averages. Mode aerosol mass mixing ratio The mass mixing ratio of species \\(s\\) in mode \\(m\\) is denoted by \\(q_{sm}\\) . The mass mixing ration of the mode [kg aerosol / kg air] is then \\begin{equation}\\label{mode_mixing_ratio} q_{m} = \\sum_{s\\in m} q_{sm}. \\end{equation} Modally averaged aerosol density The density of aerosol species \\(s\\) in mode \\(m\\) is denoted \\(\\rho_{sm}\\) . The average modal density [kg aerosol / m \\(^3\\) aerosol] is \\begin{equation}\\label{mode_density} \\rho_m = \\sum_{s\\in m}q_{sm} \\rho_{sm} \\left(\\sum_{s\\in m} q_{sm}\\right)^{-1} = \\frac{\\sum_{s\\in m}q_{sm}\\rho_{sm}}{q_m}. \\end{equation} Modally averaged hygroscopicity The hygroscopicity of species \\(s\\) in mode \\(m\\) is denoted \\(b_{sm}\\) . The mode-averaged hygroscopicity [-] is \\begin{equation}\\label{mode_hygro} b_m = \\sum_{s\\in m} \\frac{q_{sm} b_{sm}}{\\rho_{sm}}\\left(\\sum_{s\\in m} \\frac{q_{sm}}{\\rho_{sm}}\\right)^{-1}. \\end{equation} Modal mean particle volume The per-particle mean volume for each mode \\(m\\) [m \\(^3\\) /particle] is \\begin{equation}\\label{mode_particle_volume} {V_{m}} = \\frac{1}{N_m}\\sum_{s\\in m} \\frac{q_{sm}}{\\rho_{sm}}. \\end{equation} Modal geometric mean particle diameter The geometric mean diameter of the particles in mode \\(m\\) [m] is \\begin{equation}\\label{mode_particle_diameter} {D_{m}} = \\sqrt[3]{\\frac{\\pi}{6}{V_{Pm}}}\\exp\\left(-\\frac{3}{2}\\log^2 \\sigma_m\\right). \\end{equation}","title":"Multi-Species Modes"},{"location":"processes/","text":"Aerosol Processes Haero offers implementations for each of the important stages in the aerosol life cycle. Here we describe the physics of each stage, the approximations made by the associated parametrizations, and the implementations of the underlying prognostic and diagnostic processes. Each process is independent of all other processes. In other words, state variables are taken directly from the prognostics and diagostics passed to the process, and no assumptions are made about how these state variables were computed. Aerosol process An aerosol process computes a tendency , which provides the right-hand-side for a differential equation solved either by Haero or its model. In this sense, an aerosol process is prognostic . Processes may need intermediate quantities using the available state data and metadata to evaluate their tendencies. These intermediate quantities are diagnostic in the sense they they can be computed, or diagnosed, from the current state variables; they are not evolved in time by either Haero or its host model. They are computed by diagnostic functions; storage of these quantities depends on their use in various aerosol processes and/or the host model. Diagnostic function A diagnostic function updates any relevant diagnostic variables in place at simulation time \\(t\\) . Diagnostic functions are associated with the design of Kokkos kernel functors . In Haero, we apply a design priniciple: each diagnostic function updates exactly 1 diagnostic quantity. So each diagnostic function is launched as a separate kernel. Independent aerosol processes Every aerosol process is independent of other aerosol processes. Specifically: a process takes a set of state variables and diagnostics, and using only these variables , it computes a set of tendencies for the prognostic state variables at simulation time \\(t\\) . This process independence is a dramatic departure from prior implementations of aerosol physics in MAM. Any sequential coupling of processes must be performed by a host model. With this assumption, it's possible to recover the legacy MAM algorithms by constructing a coupling procedure that follows the relevant assumptions. But it's also possible to construct more sophisticated coupling processes that take advantage of advances in numerical analysis.","title":"Aerosol Processes"},{"location":"processes/#aerosol-processes","text":"Haero offers implementations for each of the important stages in the aerosol life cycle. Here we describe the physics of each stage, the approximations made by the associated parametrizations, and the implementations of the underlying prognostic and diagnostic processes. Each process is independent of all other processes. In other words, state variables are taken directly from the prognostics and diagostics passed to the process, and no assumptions are made about how these state variables were computed. Aerosol process An aerosol process computes a tendency , which provides the right-hand-side for a differential equation solved either by Haero or its model. In this sense, an aerosol process is prognostic . Processes may need intermediate quantities using the available state data and metadata to evaluate their tendencies. These intermediate quantities are diagnostic in the sense they they can be computed, or diagnosed, from the current state variables; they are not evolved in time by either Haero or its host model. They are computed by diagnostic functions; storage of these quantities depends on their use in various aerosol processes and/or the host model. Diagnostic function A diagnostic function updates any relevant diagnostic variables in place at simulation time \\(t\\) . Diagnostic functions are associated with the design of Kokkos kernel functors . In Haero, we apply a design priniciple: each diagnostic function updates exactly 1 diagnostic quantity. So each diagnostic function is launched as a separate kernel. Independent aerosol processes Every aerosol process is independent of other aerosol processes. Specifically: a process takes a set of state variables and diagnostics, and using only these variables , it computes a set of tendencies for the prognostic state variables at simulation time \\(t\\) . This process independence is a dramatic departure from prior implementations of aerosol physics in MAM. Any sequential coupling of processes must be performed by a host model. With this assumption, it's possible to recover the legacy MAM algorithms by constructing a coupling procedure that follows the relevant assumptions. But it's also possible to construct more sophisticated coupling processes that take advantage of advances in numerical analysis.","title":"Aerosol Processes"},{"location":"testing/","text":"Testing Aerosol Processes","title":"Testing Aerosol Processes"},{"location":"testing/#testing-aerosol-processes","text":"","title":"Testing Aerosol Processes"},{"location":"test_case_desc/","text":"Test case descriptions This folder contains documentation for our test cases. So far, this documentation resides in scripts that may require other software (e.g., Mathematica) to access. As the work matures, we will write up summaries for each aerosol test case in a .tex file and include it in our design docs. In the meantime, this folder serves as a reference point and collaborative foundation.","title":"Test case descriptions"},{"location":"test_case_desc/#test-case-descriptions","text":"This folder contains documentation for our test cases. So far, this documentation resides in scripts that may require other software (e.g., Mathematica) to access. As the work matures, we will write up summaries for each aerosol test case in a .tex file and include it in our design docs. In the meantime, this folder serves as a reference point and collaborative foundation.","title":"Test case descriptions"}]}